通用资料记录

# Linux

## linux命令与shell

### 文件大小

#### df命令



#### du命令

统计当前文件夹下各个文件夹的大小du -h --max-depth=1

统计所有层级文件du -h，（可用于列出所有文件夹和文件）



### 进程

#### 获得进程ID

```shell
ps |grep kms_master|head -n 1|awk \'(NR=1){print $1}\'
```

#### 获得进程依赖so和内存smaps

cat /prov/进程id/maps

cat /prov/进程id/smaps，包含每个进程的详细内存

smaps内容解释：

VSS - Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）
RSS - Resident Set Size 实际使用物理内存（包含共享库占用的内存）
PSS - Proportional Set Size 实际使用的物理内存（均摊共享库后占用的内存），均摊方式：共享库总内存/进程数量
USS - Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）

一般：VSS >= RSS >= PSS >= USS

- **VSS - Virtual Set Size （用处不大）**

  虚拟耗用内存（包含共享库占用的全部内存，以及分配但未使用内存）。其大小还包括了可能不在RAM中的内存（比如虽然malloc分配了空间，但尚未写入）。VSS 很少被用于判断一个进程的真实内存使用量。

  VSS=进程自身占用内存（含虚拟耗用：分配但尚未使用的内存）+ 共享库总内存（进程1的共享部分，进程2共享部分，进程3共享部分；均摊=总÷3)

- **RSS - Resident Set Size （用处不大）**

  实际使用物理内存（包含共享库占用的全部内存）。但是RSS还是可能会造成误导，因为它仅仅表示该进程所使用的所有共享库的大小，它不管有多少个进程使用该共享库，该共享库仅被加载到内存一次。所以RSS并不能准确反映单进程的内存占用情况。

  RSS=进程自身占用内存（不含虚拟耗用）+ 共享库总内存（进程1的共享部分，进程2共享部分，进程3共享部分；均摊=总÷3)

- **PSS - Proportional Set Size （仅供参考）**

  实际使用的物理内存（比例分配共享库占用的内存，按照进程数等比例划分）。

  例如：如果有三个进程都使用了一个共享库，共占用了30页内存。那么PSS将认为每个进程分别占用该共享库10页的大小。

  PSS是非常有用的数据，因为系统中所有进程的PSS都相加的话，就刚好反映了系统中的 总共占用的内存。而当一个进程被销毁之后， 其占用的共享库那部分比例的PSS，将会再次按比例分配给余下使用该库的进程。这样PSS可能会造成一点的误导，因为当一个进程被销毁后， PSS不能准确地表示返回给全局系统的内存。

  PSS=进程自身占用内存（不含虚拟耗用）+ 共享库总内存（均摊；均摊=总÷3)

- **USS - Unique Set Size （非常有用）**

  进程独自占用的物理内存（不包含共享库占用的内存）。USS是非常非常有用的数据，因为它反映了运行一个特定进程真实的边际成本（增量成本）。当一个进程被销毁后，USS是真实返回给系统的内存。当进程中存在一个可疑的内存泄露时，USS是最佳观察数据。

  USS=进程自身占用内存（不含虚拟耗用）

### sed(stream editor)文本操作

#### 删除指定行

```shell
sed -i 'Nd' filename 【N 为行数】

特别的，删除最后一行为：
sed -i '$d' filename 【$ 代表的是最后一行】

【提示】：
cat -n filename //可以从1开始输出显示行号
grep -n "指定行内容" filename //显示指定行行号
```

#### 插入到某行

```shell
①知道该行行号
sed -i 'Ni 要添加内容' filename //第N行插入要添加的内容，原来该行的内容后移

②知道该行内容：
插入到某行上面
sed -i '/定位字符串/i 插入字符串' filename

插入到某行下面
sed -i '/定位字符串/a 插入字符串' filename

补充echo，文末增加一行可使用如下语句：
echo "\n插入字符串" >> filename
```

#### 替换某字符串

```shell
①知道该行行号
sed -i 'Nc 替换内容' filename //替换第N行内容

②知道该行内容
sed -i 's/原字符串/替换字符串/' filename
sed -i 's/原字符串/替换字符串/g' filename 

说明：
s///: 从每一行的行首开始，匹配到第一个符合的字段，就会跳到下一行（同一行中可能有多个匹配字段）
s///g：表示全局替换，匹配每一行从行首到行尾的所有字符
```

#### 替换字符串中部分内容，其实是上边内容的升华用法

```sh
sed -i 's/^\(字符串段1\).*\(字符串段2\)$/\1放入替换段1与段2之间的内容\2/' filename

解读：
^是正则表达式匹配字符串开始位置
$是正则表达式匹配字符串结束位置
\1引用了第一个()匹配到的内容
\2引用了第二个()匹配到的内容
.*为两对括号中间的所有内容
```

![img](https://img2020.cnblogs.com/blog/816372/202105/816372-20210514101839438-1583797475.png)

#### 指定行添加删除注释

```shell
添加注释
加【#】：
sed -i 's/^指定行字符串/#&/g' filename
加【//】：
sed -i 's/^指定行字符串/\/\/&/g' filename （//由于有特殊含义，前面加\去掉特殊含义）

举例：
 > on property:sys.boot_completed=1
 >     start gps_upgrade
 > root:/vendor/etc/init/hw # sed -i 's/^.*start gps.*/#&/' init.tmp.rc (字符串不一定要写完整行，能唯一标识这一行即可。符合条件的字符串会全部都被添加上注释)
 > root:/vendor/etc/init/hw # 
 > root:/vendor/etc/init/hw # cat init.tmp.rc
 > on property:sys.boot_completed=1
 > #    start gps_upgrade 

删除注释
sed -i 's/^#\(指定行字符串\)/\1/g' filename
```

#### 	其他

```shell
# 对每行匹配到的第一个字符串进行替换
sed -i 's/原字符串/新字符串/' ab.txt 
 
# 对全局匹配上的所有字符串进行替换
sed -i 's/原字符串/新字符串/g' ab.txt 
 
# 删除所有匹配到字符串的行
sed -i '/匹配字符串/d'  ab.txt  
 
# 特定字符串的行后插入新行
sed -i '/特定字符串/a 新行字符串' ab.txt 
 
# 特定字符串的行前插入新行
sed -i '/特定字符串/i 新行字符串' ab.txt
 
# 把匹配行中的某个字符串替换为目标字符串
sed -i '/匹配字符串/s/源字符串/目标字符串/g' ab.txt
 
# 在文件ab.txt中的末行之后，添加bye
sed -i '$a bye' ab.txt   
 
# 对于文件第3行，把匹配上的所有字符串进行替换
sed -i '3s/原字符串/新字符串/g' ab.txt

```







javascript:document.body.contentEditable='true';document.designMode='on';

### 输出重定向符

| 命令        | 说明                                               |
| :---------- | :------------------------------------------------- |
| cmd > file  | 将输出重定向到 file。                              |
| cmd < file  | 将输入重定向到 file。                              |
| cmd >> file | 将输出以追加的方式重定向到 file。                  |
| n > file    | 将文件描述符为 n 的文件重定向到 file。             |
| n >> file   | 将文件描述符为 n 的文件以追加的方式重定向到 file。 |
| n >& m      | 将输出文件 m 和 n 合并。                           |
| n <& m      | 将输入文件 m 和 n 合并。                           |
| << tag      | 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 |

> 注：

- 文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）



**输出**

以下两组是等价的

```shell
echo "hello" > t.txt  等价于  echo "hello" 1> t.txt # stdout输出重定向
cmd >> t.txt 等价于 cmd 2>> t.txt # stderr输出追加输出到t.txt
```

如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写，（用到了**n >& m** 将输出文件 m 和 n 合并）

```shell
cmd > file 2>&1
或 cmd >> file 2>&1
```

如果希望对 stdin 和 stdout 都重定向，可以这样写：(command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。)

```shell
cmd < file1 >file2 &
```

- 注：最后一个&表示把条命令放到后台执行

每次都写">log 2>&1"太麻烦，有以下两种简写方式

```shell
cmd >&log
cmd &>log
```

特殊：**>&**符号的理解

```shell
cmd > file 2>&1
```

符号>&是一个整体，重定向的过程，可理解为指针指向。

```shell
#默认1指向屏幕
#因cmd > file改变指向，表示1指向file （1-->file）
#然后2>&1，使得2重定向到1，表示2指向1 （2-->1，又1-->file，则2-->file）
```



**输入**

“<<”：Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。

格式如下：

```shell
cmd << test
    test_contents
test
```

> 注：

- **作用**：将两个test之间的内容（test_contents)作为输入传入给cmd命令。
- 结尾的test必须顶格写，不能有缩进或其他任何字符，其后也不能跟随任何字符。
- 开始的test前后可有空格，自动忽略。

来看个例子：

使用wc -l计算here document的行数

```shell
wc -l << EOF
    line1
    line2
    line3
    line4
EOF
#输出结果
4
```

也可用在脚本中，以下是 test.sh

```shell
#!/bin/bash
wc -l << EOF
    line1
    line2
    line3
    line4
EOF
```

运行后输出

```shell
line1
line2
line3
line4
```



**/dev/null**

使用重定向到/dev/null文件，让某个命令执行后输出的结果不打印在屏幕上。

```shell
cmd > /dev/null
```

/dev/null：一特殊文件，写入的内容会被丢弃，若读/dev/null则读入为空。常用于达到"禁止输出"的效果。

若希望屏蔽stdout和stderr，可写成：

```shell
cmd > /dev/null 2>&1
```

> 注：

- 0是stdin的文件fd，1是stdout，2是stderr。
- 2和>间不能有空格，2>一起才表示错误输出。

### shell里定义整形变量、获得文件夹下所有文件

```shell
# 定义一个不断累加的j，对文件夹下所有文件创建软链接
j=1
for i in ../ln_test_src/* ; do
   ln -s ${i} create_ln/${j}
   j=$((j+1))
   done
```

### shell函数、参数、输入参数

```shell
if [ $# -le "0" ] #输入文件<=0个
    then
        echo "please input one test file! Like \"$0 filename.c\""
        exit 1
fi

if [ $# -ge "2" ] #输入文件>=2个
    then
        echo "unsupport input multi-file yet. please input one test file! Like \"$0 filename.c\""
        exit 1
fi
echo "runing $(basename $0) to test $1"
TestCaseName=$1
ClangOutputFileName="$(basename $TestCaseName).ll"
# ClangRuner="/code/seahorn/build/run/clang+llvm-5.0.0-linux-x86_64-ubuntu16.04/bin/clang-5.0"
ClangRuner="/code/usellvm10/SVF/llvm-10.0.0.obj/bin/clang-10"
# RunClang="$ClangRuner -c -emit-llvm -S $TestCaseName -o $ClangOutputFileName"
RunClang="$ClangRuner -S -c -Xclang -disable-O0-optnone -fno-discard-value-names -emit-llvm $TestCaseName -o $ClangOutputFileName"
echo "$RunClang"
$RunClang

Mem2regCmd="/code/usellvm10/SVF/llvm-10.0.0.obj/bin/opt -S -mem2reg $ClangOutputFileName -o $ClangOutputFileName"
echo "$Mem2regCmd"
$Mem2regCmd

# RmDotFile="rm *.dot"
# $RmDotFile

# SeaDsaBin="/code/sea-dsa/build/run/bin/seadsa"
SeaDsaBin="/code/usellvm10/sea-dsa/build/run/bin/seadsa"
# RunSeaDsaCmd="$SeaDsaBin -sea-dsa=cs -sea-dsa-type-aware -sea-dsa-stats -sea-dsa-dot $ClangOutputFileName"
RunSeaDsaCmd="$SeaDsaBin -sea-dsa=cs -sea-dsa-type-aware -sea-dsa-dot $ClangOutputFileName"
echo "$RunSeaDsaCmd"
$RunSeaDsaCmd

for file in $(ls ./ | grep ".dot$")
do
    GenPdfCmd="dot -Tpdf $file -o $(basename $TestCaseName)_$file.pdf"
    echo "$GenPdfCmd"
    $GenPdfCmd
done
```



# 

# OS与体系结构



# 

# 编译器领域

# 词法分析器

华为伽罗瓦实验室——编译器/语言与程序分析团队；483465 赖...

---

词法分析器：字符流->转换->记号流
字符流：读入源码的字符串，如c一般是ASCII格式字符流，java是Unicode字符流。
记号流：编译器内定义的数据结构，用于标识token（词法单元）

## 手动实现——转移图算法

原理就是每读入一个字符，通过switch...case...转移状态

```c
token nextToken()
  c = getChar()
  switch (c):
    case '<':
      c = getChar():
        switch (c):
          case '=': return LE;
          case '>': return NE;
          default: rollback(); return LT；
    case '=':
      return EQ;
    case '>':
      c = getChar();
      ...  // 后面类似
```

**区分关键字和标识符**
在状态转移图生成token的过程中，标识符通常是大小写字母加下划线开头及构成、外加跟上数字够构成，而语言中定义标识符通常由字母构成，关键字是标识符的一个子集。
两种办法：

1. 在转移图中增加新的分支，即增加识别标识符的边。
2. 构建一张关键字哈希表，先识别为标识符，后查哈希表，完美哈希可在O(1)时间完成。

## 自动生成

### 有限状态自动机（FA）

输入字符串 >>> FA >>> {yes, no}
FA:  M = (Σ, S, q0, F, δ)，其中Σ是字母表（ASCII），S是状态集，q0是初始状态，F是终结状态集，δ是转移函数。
**非确定的有限状态自动机（NFA）**：对任意的字符，有多个状态可转移。转移函数的目标状态存在多个
**确定的有限状态自动机（DFA）**：对任意的字符，最多有一个状态可转移。目标状态只存在一个

词法分析器自动生成的过程
**正则表达式RE** --- (Thompson算法) ---> **NFA** --- (子集构造算法) ---> **DFA** --- (Hopcroft最小化算法) ---> 词法分析器代码

### RE>>>NFA：Thompson 算法

数学归纳的思想，对RE的结构做归纳，对基本RE直接构造、对复合RE递归构造。核心是一个递归算法（<100行C）。

```shell
e -> ε(空)   直接构造
  -> c       直接构造
  -> e1 e2    递归构造
  -> e1 | e2  递归构造
  -> e1*      递归构造
```

构造NFA
![NFA1](http://tva1.sinaimg.cn/large/d0043e63gy1h414jo8fchj209l0b8758.jpg)

### 子集构造算法

对正则表达式a(b|c)*进行子集构造，完成NFA到DFA的转换。

![正则表达式a(b|c)*的状态转移图](http://tva1.sinaimg.cn/large/d0043e63gy1h41y11xpvpj20nq085gn0.jpg)

```shell
首先起始状态q0 = n0，读入一个字符a后
n0(q0) →a→ n1，n1继续读入0个字符（空字符ε），可进入其他状态，这些状态是等价的。列出所有可转移的状态
       →a→ {n1，n2, n3, n4, n6, n9}, 记为q1，这些是读入a以后能走到的所有状态，把这六个节点用一条线穿起来，称之为一条边界。因包含结束状态n9，所以q1是结束态。
n4(q1) →b→ n5, 继续读入b时，遍历q1的6个元素，发现n1到n3都不能接受b，到n4时发现可转移到n5。通过ε走向：
       →b→ {n5, n8, n9, n3, n4, n6}, 记为q2，同理q2也是结束状态。
q1(n6) →c→ n7 ... 
q2(n6) →c→ n7 ...
其他同样道理，就得到了新的状态转移图，是一个DFA，简化示意如下
q0 →a→ q1 →b→ q2 →c→ ...
```

​    子集构造算法是一个不动点算法，因为原NFA的状态总数是确定的，假设状态总数为N，时间复杂度最坏情况下是2^N(2的N次方)。但实际情况常是一个线性时间复杂度，因为并不是每个子集都会出现。

​    **ε闭包**：读入一个字符后，看会走到哪些节点，同时继续考虑这些节点通过空字符ε会到达哪些节点，所有这些节点构成的集合就是ε闭包。比如上文的q1={n1，n2, n3, n4, n6, n9}就是一个ε闭包。

​    那如何找出ε闭包呢？主要使用深度有限算法的思想去完成。ε闭包计算算法（深度优先）：

```c
/*ε-closure:基于深度优先遍历*/
set closure = {}; //一开始是一个空集
void eps_closure (x) {//要计算状态x的闭包
    closure += {x} //首先将x并入集合中，就如上文的q1最先把n1加入
    foreach (y: x --ε--> y) {//接下来遍历所有x通过ε边可到达的节点y，最多把所有节点都遍历一遍O(N)
        if (!visited(y)) // 如上文从n1出发,首先遍历到n2，n2未加入，则继续深度遍历
            eps_closure (y)//递归调用，继续寻找n2的所有ε边可达的节点。
    }
}
```

另一种是广度优先的算法，也可实现

```c
set closure = {}; //一开始是一个空集
Q = []; // queue
void eps_closure (x) {//要计算状态x的闭包
    Q = [x];
    while (Q not empty) {
        q = deQueue(Q);//出栈
        closure += q;//增加集合元素
        foreach (y: q--ε-->y)
            if (!visited(y))
                enQueue(Q, y)//入栈
    }
}
```

子集构造算法的算法思路，并以上文提到的正则表达式a(b|c)*为例描述NFA（图）转换成DFA的过程。

```c
/*子集构造算法：工作表算法，该代码适用所有场景*/
q0 = eps_closure(n0); //构建起始状态q0，也即求n0的ε闭包
Q = {q0};
workList = q0;//通常是一个队列
while (workList != []) {
    remove q from worklist;
    foreach (character c) {//循环所有字符（若是ASCII码，256次），第一次只有'a'才会有转换，只接受a
        t = eps_closure (delta(q, c));//如delta(q0, 'a')={n1},再对n1求ε闭包ε-closure({n1})
        D[q, c] = t;//得到的t就是上文描述的q1=t={n1, n2, n3, n4, n6, n9},将t增加到DFA里
        if (t not in Q)//如果这个状态不在Q里，则是个新的有效状态，如第一次生成的q1
            add t to Q and workList;//保存新的状态q1
    }
}
// D[q, c]=t,表示DFA图里的转换关系，如D[q0, 'a']=q2={n1, n2, n3, n4, n6, n9}，图示q0--a-->q1
////a(b|c)*的NFA转换成DFA的过程：
/*第一轮：q0=n0,建立Q={q0}，workList=[q0]；到达while循环，此时workList不为空，进入循环。
将q0移除，workList=[]; 遍历可接收的字符，只有a，计算出t=q1={n1,n2,n3,n4,n6,n9}
添加DFA[q0, 'a']=q1, 此时t=q1不在Q里，增加q1，使得Q={q0, q1},workList=[q1]。结束for循环。
///////////////////////////////////////////////////////////////////////
第二轮：回到while循环，workList=[q1],不为空，进入while循环，开始第二轮。将q1从workList移除，变为[]。
第二轮的for可接受b和c，所以可循环两次；先循环b，delta(q1, 'b')={n5}，
所以对n5求闭包eps_closure ({n5})，得到t=q2={n5, n8, n9, n3, n4, n6};
DFA的转换关系D[q1, 'b']=t=q2；此时q2也不在Q，则有Q={q0, q1, q2},workList=[q2]。

回到for循环，还可接收字符'c'，进入for循环。
delta(q1, 'c')={n7}，对n6求ε闭包eps_closure ({n7})，得到t=q3={n7, n8, n9, n3, n4, n6}
更新DFA转换关系D[q1, 'c']=t=q3，可见q3也不知Q里，增加Q={q0, q1, q2, q3}，workList=[q2, q3]。
结束for循环，回到while循环。
///////////////////////////////////////////////////////////////////////
第三轮：此时workList=[q2, q3]，首先求q2={n5, n8, n9, n3, n4, n6}的转换，先让workList=[q3]；
在for循环中，根据q2的原NFA状态的集合可知，只有n4能接收b、n6能接收c，所以也是两次循环。
所以又是delta(q2, 'b')={n5}，又会得到和q2一样的闭包{n5, n8,n9,n3,n4,n6}，已在Q里，所以不用再添加。
对'c'又有delta(q1, 'c')={n7}，求闭包得到{n7, n8, n9, n3, n4, n6}，和q3一样，不用再添加。

第二次while循环，针对q3，同上一次也是接收b和c，也会分别得到q2和q3。

workList为空结束循环。
*/
```

最终得到a(b|c)*对应的DFA的转换图如下

![a(b|c)*的DFA图](http://tva1.sinaimg.cn/large/d0043e63ly1h428xajcgkj20ar09774o.jpg)

### Hopcroft最小化算法

​    上一节描述的正则表达式a(b|c)*的DFA图简化过程，能够与表达式的含义对上。

![a(b|c)*的DFA最小化过程](http://tva1.sinaimg.cn/large/d0043e63ly1h44mdiqvb0j20n909b3zt.jpg)



​    而简化用到的算法就是Hopcroft最小化算法。算法思路如下：

```c
// 基于等价类的思想
split(S) {
    for (c in character) { // 遍历所有的字符
        if (c can split S)
            split S into T1,...,TK;
    }
}
Hopcroft () {
    split all nodes into N, A; //其中N是非结束状态，A是结束状态。最开始将所有节点分成两类
    while (set is still changes) { //增加标识看是否还有集合在变化
        split(set)
    }
}
```

上述DFA的最小化过程如下图所示，左边是非结束状态N{ q0 }，右边是结束状态结合A{q1, q2, q3}，遍历到首先N不能再切分了。看A，遍历到b时，发现状态转换都还在A内部，同理c也一样，可见都不能对A进行切分，则可合成一个状态q5。得到了最终简化图。

![a(b|c)*的DFA图通过算法简化过程图](http://tva1.sinaimg.cn/large/d0043e63gy1h49z0ytri6j20nw0900vc.jpg)

再看一例子fee | fie=f (ee | ie)表达式，如下文图示，左上方时原始DFA图，初始化按照结束状态和非结束状态进行划分成两个大的集合N和A；可见A无可接受字符，也无转移出去的状态，可知A已不可再切分，将有q3和q5合并成一个新的结束状态，当收到字符'e'时转移到该状态。接下来开始遍历字符，遍历到e时，N里的q1、q2、q4都可接收'e'，但行为不一样，q1接收后转移到q2，而q2和q4都转移到A，则可知e能对集合划分出两个类，q2和q4并入一个集合，剩余q0和q1；继续遍历到'f'时，可知又可对q0和q1进行切分；继续遍历则不能继续切分，得到最终最小化转移图。

![f (ee | ie)的DFA最小化过程图](http://tva1.sinaimg.cn/large/d0043e63ly1h4a8a3whawj20oy0eqq9h.jpg)

## DFA的代码表示

​    DFA是一个有向图，在实际代码中，常见的有转移表、哈希表、跳转表等表示方式。

### 转移表算法

就是将状态和可接收的字符构建一张表，如前边的例子a(b|c)*根据其最小化后的DFA可生成如下表格表示。

| 状态\|字符 |  a   |  b   |  c   |
| :--------: | :--: | :--: | :--: |
|     0      |  1   |      |      |
|     1      |      |  1   |  1   |

转移表代码由两部分组成，分别是如上面表格一样的转移表和词法分析器驱动代码组成，转移表生成后构成固定表格，如上文2x3的表格（如果是c这些ASCII码的程序，则是Nx256的，N通常会非常大），驱动代码则负责读入源程序、查表、输出词法分析器结果（tocken)。算法代码示例如下：

```c
// 转移表
char table[M][N];//这里是2x3
table[0]['a'] = 1;
table[0]['b'] = 1;
table[0]['c'] = 1;
// 其他项则都为无效项，比如统一填入-1

// 驱动代码算法
NextToken() {
    state = 0;
    stack = [];//stack栈
    while (state != ERROR) {
        c = GetChar();
        if (state is ACCEPT) {
            ClearStack(stack);
        }
        push(state);
        state = table[state][c];
    }
    
    while (state is not ACCEPT) {
        state = Pop();
        Rollback();
    }
}
```

这个算法的思路其实很简单，跟着例子走一遍就理解了。以a(b|c)*表达式及其最简DFA为例，前边内容已列出了其状态转移表，假如此时输入的是"abcabc"这样一个串，下文表格内容逐句分析。

| 环节                     | 详细                                                         | stack当前与变化                         | state当前与变化     |
| ------------------------ | ------------------------------------------------------------ | --------------------------------------- | ------------------- |
| 1. 调用NextToken函数     | 初始化state=0状态，初始状态。新建空栈。                      | 当前：[ ] 空栈                          | 当前：0(初始态)     |
| 2. 开始第一个while循环   | 进来判断state是不是Err无效状态（转移表中的空白格子，通常值为-1），当前是0，进入循环。<br>读取第一个字符’a‘（"[a]bcabc"），判断当前是不是ACCEPT结束状态（即转移表的状态1），当前不是。将state压栈，通过查表更新state=table[0]/['a']=1，即跳转到1状态。 | 当前：[ ] → 变化： [0, ]                | 当前：0 → 变化： 1  |
| 3. 第二次while 1循环     | 继续判断当前state，非无效状态。继续读入'b'字符（"a[b]cabc"），此时state是结束状态1，清空stack。又将当前state入栈，更新state=table[1]/['b']依然等于1。 | 当前：[0, ] → 变化： [ ] → 变化： [1, ] | 当前：1 → 变化： 1  |
| 4. 第三次while 1循环     | 当前state也不是无效状态，继续读入’c‘字符（"ab[c]abc"），此时state也是结束状态1，清空stack；随后继续入栈1和更新state=1。 | 当前：[1, ] → 变化： [ ] → 变化： [1, ] | 当前：1 → 变化： 1  |
| 5. 第四次while 1循环     | 当前state也不是无效状态，继续读入’a‘字符（"abc[a]bc"），当前state也是结束状态1，清空stack；随后入栈1，更新state=table[1]/['a']=ERROR（-1）。 | 当前：[1, ] → 变化： [ ] → 变化： [1, ] | 当前：1 → 变化： -1 |
| 6. 结束第一个while 1循环 | 再次回到while循环时，此时state是无效循环，则结束第一个while循环 | 当前：[1, ]                             | 当前：-1            |
| 7. 进入第二个while 2循环 | 当前state=-1，不是结束状态，则进入循环内代码。               | 当前：[1, ]                             | 当前：-1            |
| 8. 第一次while 2循环     | stack弹栈并更新state=1，rollback()作用是回滚一个字符，即让读入当前字符的指向指针向前移动一个字符，原来指向了"abc[a]bc"，回滚回"ab[c]abc" | 当前：[1, ] → 变化： [ ]                | 当前：1             |
| 9. 结束第二个while 2循环 | 当前state=1，是结束状态，不再进入循环。结束NextToken函数，以初始位置到当前指向指针位置标识出了识别出来的字符Token="abc"。后面的字符则重新调用NextToken函数。 | 当前：[ ]                               | 当前：1             |

**最长匹配原则**

词法分析器中通常遵循最长匹配原则，比如c语言中，有个用户自定义标识符字符串是“ifNotOk"，编译器识别时不能只识别出一个if就结束了，这样就错误识别成一个关键字if了，显然是不对的。下边以"ifif"表达式的状态转移图为例，进一步说明最长匹配原则和回滚过程。其DFA转移图如下图所示。

![ifif的DFA转移图](http://tva1.sinaimg.cn/large/d0043e63gy1h4gy0sergej20hx027jrl.jpg)

假如输入了一个字符串"ifif\0"，识别步骤如下文表格描述。

| 环节                   | 详细                                                         | stack当前与变化                            | state当前与变化     |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------ | ------------------- |
| 1. 初始化              | 调用NextToken函数，初始化state=0状态，初始状态。新建空栈。   | 当前：[ ] 空栈                             | 当前：0(初始态)     |
| 2. 开始第一个while循环 | 进来state当前是0，进入循环。读取第一个字符’i‘（"[i]fif\0"），判断当前不是ACCEPT结束状态。将state压栈，通过查表更新state=table[0]/['i']=1，即跳转到1状态。 | 当前：[ ] → 变化： [0, ]                   | 当前：0 → 变化： 1  |
| 3. 第二次while 1循环   | 判断当前state，非无效状态。读入'f'字符（"i[f]if\0"），当前state=1，不是结束状态。又将当前state入栈，更新state=table[1]/['f']=2。 | 当前：[0, ] → 变化： [0, 1, ]              | 当前：1 → 变化： 2  |
| 4. 第三次while 1循环   | 当前state也不是无效状态，继续读入’i‘字符（"if[i]f\0"）；此时state是结束状态2，清空stack；随后继续入栈2和更新state=3。 | 当前：[0, 1, ] → 变化： [ ] → 变化： [2, ] | 当前：2 → 变化： 3  |
| 5. 第四次while 1循环   | 当前state也不是无效状态，继续读入’f‘字符（"ifi[f]\0"），当前state不是结束状态；入栈3，更新state=table[3]/['f']=4。 | 当前：[2, ]  → 变化： [2, 3, ]             | 当前：3 → 变化： 4  |
| 6. 第五次while 1循环   | 当前state也不是无效状态，继续读入’\0‘字符（"ifif[\0]"），当前state=4是结束状态，清空栈；入栈4，更新state=table[3]/['\0']进入一个不在转移图内的状态，也即一个错误状态。<br>随后结束第一个while循环。 | 当前：[2, 3, ] → 变化： [ ] → 变化： [4, ] | 当前：4 → 变化： -1 |
| 7. 进行第二个while循环 | 跟上一个例子表格里第7~9步一样，回滚一次后，回到指向’f‘（"ifi[f]\0"），结束循环，结束函数调用。 | 当前：[4, ] → 变化： [ ]                   | 当前：-1 → 变化： 4 |

如果输入的是"ifii"，分析过程如下。

| 环节                   | 详细                                                         | stack当前与变化                            | state当前与变化     |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------ | ------------------- |
| 1. 初始化              | 调用NextToken函数，初始化state=0状态，初始状态。新建空栈。   | 当前：[ ] 空栈                             | 当前：0(初始态)     |
| 2. 开始第一个while循环 | 进来state当前是0，进入循环。读取第一个字符’i‘（"[i]fii"），判断当前不是ACCEPT结束状态。将state压栈，通过查表更新state=table[0]/['i']=1，即跳转到1状态。 | 当前：[ ] → 变化： [0, ]                   | 当前：0 → 变化： 1  |
| 3. 第二次while 1循环   | 判断当前state，非无效状态。读入'f'字符（"i[f]ii"），当前state=1，不是结束状态。又将当前state入栈，更新state=table[1]/['f']=2。 | 当前：[0, ] → 变化： [0, 1, ]              | 当前：1 → 变化： 2  |
| 4. 第三次while 1循环   | 当前state也不是无效状态，继续读入’i‘字符（"if[i]i"）；此时state是结束状态2，清空stack；随后继续入栈2和更新state=3。 | 当前：[0, 1, ] → 变化： [ ] → 变化： [2, ] | 当前：2 → 变化： 3  |
| 5. 第四次while 1循环   | 当前state也不是无效状态，继续读入’i‘字符（"ifi[i]"），当前state不是结束状态；入栈3，更新state=table[3]/['i']=ERROR。随后结束第一个循环。 | 当前：[2, ]  → 变化： [2, 3, ]             | 当前：3 → 变化： -1 |
| 6. 进入第二个while循环 | 当前state=-1，进入循环，弹栈状态3，回滚一个字符（"if[i]i"）。 | 当前：[2, 3, ] → 变化： [2, ]              | 当前：-1 → 变化： 3 |
| 7. 第二次while循环     | 当前state=3，非结束状态，第二次循环。弹栈状态2，继续回滚到（"i[f]ii"）。随后判断是结束状态，结束循环，结束函数调用。识别出Token="if"。 | 当前：[2, ] → 变化： [ ]                   | 当前：3 → 变化： 2  |
| 8. 再次调NextToken函数 | 第二次调NextToken函数，识别到第二个i时，发生错误状态。又回滚到了初始出入的i，本次未识别出Token，则报错未识别的标识符"ii"。 | -                                          | -                   |

### 跳转表算法

跳转表的方式就是用代码段去表示一个状态，实现跳转项的过程，如a (b|c)*的跳转表实现如下。

```c
NextToken() {
    state = 0;
    stack = [];
    GoTo_q0(state, stack);
}
GoTo_q0(state, stack){
    c = getChar();
    if (state is ACCEPT) {
        Clear(stack);
    }
    push(state);
    if (c == 'a') {
        GoTo_q1();
    }
}
GoTo_q1(state, stack){
    c = getChar();
    if (state is ACCEPT) {
        Clear(stack);
    }
    push(state);
    if (c == 'b' || c == 'c') {
        GoTo_q1();
    }
}
// 可以看出，其实就是把查表的过程用代码段实现了，思路是一样的。
// 这样做的相当于把转移表的各个项展开了。获得的好处是不用占用那么多内存了。
```

这两种实现算法的思路是一样的，只是一个用了直观些的转移表，但对于很多语言来说，表项太多，占用内存太多。而另一个则针对每个状态去单独分析跳转，这样则可需要用哪项时加载哪项，有效节约内存。比如flex用的是后者方式。



https://onebox.huawei.com/app

https://onebox.huawei.com/



# 语法分析器

语法分析器：记号流->语法分析器->抽象语法树

主要的内容和算法

- 数学理论：上下文无关文法（CFG）
  - 描述语言语法规则的数学工具
- 自顶向下分析
  - 递归下降分析算法（预测分析算法）
  - LL分析算法
- 自底向上分析
  - LR分析算法

## 上下文无关文法

上下文无关文法G是一个四元组

| G = （T, N, P, S) |
| :---------------: |

其中：

- T是终结符集合，T = {...}
- N是非终结符集合，N = {...}
- P是一组产生式规则，P = {X, X2, ...}；每条规则 X -> β1 β2 ... βn，其中X∈N，βi∈(T∪N)，->表示推导出。
- S是唯一的开始符号（非终结符），S ∈ N

下面来看一个算数表达式的上下文无关文法例子（这里只包含+和*）

```c
G = (N, T, P, S)
非终结符：N = {E}
终结符：T = {num, id, +, *}
开始符号：E
产生式规则集合：{E -> num, E -> id, E -> E + E, E -> E * E}
// 这里简化约定用 | 符号表示多条
E -> num
    | id
    | E + E
    | E * E
// 这里还约定，大写字母表示非终结符，小写字符表示终结符，E表示开始符号。
```

**推导**

1. 给定文法G，从G的开始符号S开始，用产生式的右部替换左侧的非终结符。
2. 此过程不断重复，直到不出现非终结符为止。
3. 最终的串称之为句子。

**最左推导**

每次总是选择最左侧的符号进行替换。

**最右推导**

同理，选择最右边的符号进行替换。

以下边文法表示举例推导过程：

```c
S -> N V N
N ->  t
    | g
    | w
V ->  e
    | d
// 从S出发进行替换
S -> N V N -> t V N -> t d N -> t d w
```

**语法分析的功能**

给定文法G和句子s，语法分析要回答的问题：是否存在对句子s的推导？

如上文的算数表达式的上下文无关文法的例子：

```c
E -> num
    | id
    | E + E
    | E * E
// 如果输入s = "5 + 8 * 9"，根据文法规则，这里应该回答“Y"。
// 而如果 s = "6 - 3"，则应该返回”N"，并报错，未识别符号“-”。
```

## 分析树与二义性文法

推导可表达成树状结构，和推导所用的顺序无关（最左、最右、其他），具备如下特点：

- 树中的每个内部节点代表非终结符
- 每个叶子节点代表终结符
- 每一步推导代表如何从双亲节点生成它的直接子节点
- 分析树的含义取决于**后续遍历**

继续以上一节算数表达式为例子

```c
文法G：
E -> num
    | id
    | E + E
    | E * E
// 推导句子 3 + 4 * 5
因为E可推导出好几个右边表达式，假设这里先随机选择，可有如下两种推导方式：
1. E -> E + E -> 3 + E -> 3 + E * E -> 3 + 4 * E -> 3 + 4 * 5, 可推导，返回Y;
2. E -> E * E -> E + E * E -> 3 + E * E -> 3 + 4 * E -> 3 + 4 * 5, 也可推导，返回Y;
```

这两种推导方式分别得到的分析树如下图所示

![算数推导文法两种推导方式得到的分析树](http://tva1.sinaimg.cn/large/d0043e63gy1h4i2yhtoh6j20sw0b1772.jpg)

可见，因为乘法的优先级比加法更高，所以第一种分析树才是对的。分析树顺序将决定程序的意义，这种现象称之为二义性文法。

**二义性文法**

给定文法G，如果存在句子S，他有两棵不同的分析树，那么称G是二义性文法。

- 从编译器的角度，二义性文法存在的问题：(1)同一个程序会有不同含义；(2)程序的运行结果不是唯一的。
- 解决方案：**文法重写**。

对上文的算术表达式文法进行重写如下，按照这个推导过程画出分析树将是正确的，且消除了二义性。

```c
文法G：
E  -> E + T
    | T
T  -> T * F
    | F
F  -> num
    | id
// 推导句子 3 + 4 * 5，消除了二义性
// E -> E + T -> T + T -> F + T -> 3 + T -> 3 + T * F
//   -> 3 + F * F -> 3 + 4 * F -> 3 + 4 * 5。
推导 3 + 4 + 5
E   -> E + T
    -> E + T + T
    -> T + T + T
    -> F + T + T
    -> 3 + T + T
    -> 3 + F + T
    -> 3 + 4 + T
    -> 3 + 4 + F
    -> 3 + 4 + 5
```

如果继续用上面这个重写后的文法推导3 + 4 + 5，按照最左推导的过程画出其分析树，后续遍历后，发先其运算的过程可满足左结合的规则。

## 自顶向下分析算法

从给定文法G的开始符号出发，随意推导出某个句子t，比较t和输入串s，如果相等则回答Y，不等则回滚换下一种方法重试，直到遍历完所有文法的可能性。因为是从开始符号出发推出句子，故称之为自顶向下分析，对应于分析树自顶向下的构造顺序。

```c
tokens[]; //从词法分析器输入的所有的tokens流
index = 0; //tokens流当前对比的是第几个的索引
stack = [E]; // E是开始符号，可推导出第一个右部
while (stack != []) {//只要stack不为空，继续遍历尝试下一个右部
    if (stack[top] is a terminal t) //如果栈的第一个元素是终结符
        if (t == tokens[i++])
            pop(); // 如果与当前输入token流匹配成功，则弹出该元素，并增加i以比较下一个
    	else
            backtrack(); //如果不匹配，则回溯，即恢复上一次的样子，i--, 当前栈顶弹出去，push回上一次弹出的元素
    else if (stack[top] is a non-terminal T) {//如果不是终结符
        pop();// 则弹出该元素
        push(the next right hand side of T);//让T的下一个没有尝试过的右部逆序入栈，逆序的目的是实现了最左推导。
    }
}
```

自顶向下的算法核心思想就是用文法从第一个开始尝试组建每一个文法组合，期间若找到完全匹配的则返回Y，若直到遍历完最后一个文法组合依然不存在，则返回N，感兴趣的可拿个实例，代入走一遍便更加理解了。这个算法因为是使用一种种组合去尝试，如果期间出现不匹配的情况，则需要回滚到上一次匹配的地方尝试下一个，所以有不断的试错和回溯的过程，同时每个token都要尝试所有排列组合，计算量太大，实际中显然是不可能的。实际工程需要线性时间的算法，避免回溯，也就是下文介绍的递归下降分析算法和LL(1)分析算法。

​    避免回溯的方法，就是考虑当前index所指向的输入token，而不是盲目去尝试，这样根据输入串的当前符号寻找文法中匹配的右部的方式，就是后面改进的算法方式，优化文法推导。

## 递归下降分析算法

递归下降分析算法是自顶向下算法的一种极其延伸，也称预测分析算法。该算法分析高效（线性时间）、容易实现、错误定位与诊断信息准确；被GCC4.0、LLVM所采用。算法的基本思想是：

- 每个非终结符构造一个分析函数
- 用前看符号指导产生规则的选择

可见构建这个算法与具体的文法直接相关，其抽象出的一般算法框架可表示如下：

```c
文法G
x ->  β11 ... β1i
    | β21 ... β2j
    | β31 ... β3k

parseX() {
    token = NextToken();
    switch(token)
        case ...: // β11 ... β1i
        case ...: // β21 ... β2j
        case ...: // β31 ... β3k
    ...
        default: Error("...")
}
```

下边以算术表达式的文法对递归下降分析算法的实现，可看出也存在一定回溯的可能，但可通过编码实现得以修正。

```c
//文法G
E -> E + T
    | T
T  -> T * F
    | F
F  -> num
    | id

// 第一种实现
ParseE() {
    token = tokens[i++];
    if (token == num) {
        ? // E + T or T应该走哪个呢
    } else Error("...");
}
// 这种写法时，就有两种方式，先尝试E+T，即先调ParseE()-->再check是不是‘+’号-->再调ParseT()。
// 发现如果不是则回溯尝试第二种可能，看是不是T这条分支，调ParseT()。但这种可通过改进代码的实现来回避。
```

利用文法的特殊性，改进代码实现，避免回溯。如下的第二种方式。
原理是观察上边文法，可拆成两种情况，分别是

- T + T + T + T...(0到∞个)，也即可看成到遇到T时，则看后面紧跟的是不是+号，如果是+号，则后面跟的肯定是T，就可自递归调用解析了。
- F * F * F * F...(0到∞个)，则为遇到F时，再看后边是不是\*号，如果是\*号，则后边紧跟的肯定是F，然后实现递归。

代码实现如下

```c
// 第二种实现
ParseE() {
    ParseT();
    token = tokens[i++];
    while (token == '+') {
        ParseT();
        token = tokens[i++];
    }
}
ParseT() {
    ParseF();
    token = tokens[i++];
    while (token == '*') {
        ParseF();
        token = tokens[i++];
    }
}
```



## LL(1)分析算法

自动生成的工具有很多，比如YACC、BISON等。LL(1)分析算法是自动生成算法的一种，其意思是：从左（L）向右读入程序，最左（L）推导，采用一个（1）前看符号。它具备分析高效（线性时间）、错误定位和诊断信息准确等特征；目前有较多开源或者商业工具采用了该算法（如ANTLR）。其算法核心思想就是表驱动的分析算法。

​    可见这个算法的核心是驱动表，也就是在原来自顶向下算法的基础上多了可查的表格及查表获得正确判断，以免去回溯。这使得表驱动的LL分析器软件架构变成如下模式，即自顶向下算法+分析表模式。

![表驱动的LL分析器软件架构图](http://tva1.sinaimg.cn/large/d0043e63ly1h56s409289j20h507tq3l.jpg)

从而得知算法实现思路，也是基于自顶向下算法，如下改进：

```c
tokens[]; 
i = 0; 
stack = [E];
while (stack != []) {
    if (stack[top] is a terminal t) 
        if (t == tokens[i++])
            pop();
    	else
            Error("..."); //不匹配，直接报错，不用回溯，因为每次入栈的都是正确的，不匹配即不正确
    else if (stack[top] is a non-terminal T) {//如果不是终结符
        pop();// 则弹出该元素
        push(the correct right hand side of T);//入栈的是正确右部，不再是下一个，
                 table[N, T]//通过查表获得正确的，本质上就是看表中有没有。
    }
}
//核心变化的地方，就在于通过分析表查找每次能入栈正确的右部，表中可查到的就是正确的
//如果入栈后比较不正确，只能说明输入的不正确，可直接报错，不用再回溯。
```

下面通过一个例子来说明查表和算法的思想。

文法与分析表

```c
S -> N V N
N ->  s //1
    | t //2
    | g //3
    | w //4
V ->  e //5
    | d //6
分析表
N\T s t g w e d
 S  0 0 0 0
 N  1 2 3 4
 V          5 6
```

比如分析句子gdw，首先起始符号S入站，开始循环，进入else分支，弹出S，自左向右N V N入栈；继续进入else分支，N出栈，查看前看符号是g，查表N行g列对应的是3，表明g在表中存在，选出第三个右部对应是g入栈。g是终结符，接着进入if分支，比对当前i指向的token和栈顶元素g，发现相等，同时i指向下一个，随后g出栈。下一次循环，是V，出栈，根据当前前看符号是d，查表是V行d列，对应是6，也就是拿到第6个右部终结符d，之后d入站，比对相同。下一个，以此类推，直到查找结束或者发现不匹配的（其实也就是表中查找不到或无效索引的）报错。

### FIRST集与算法

定义：FIRST(N)从非终结符N开始推导出的句子开头的所有可能的终结符的集合。

求FIRST集的不动点算法

```c
foreach (nonterminal N) //遍历所有非终结符N，初始化其对应的FIRST集为空集合
    FIRST(N) = {}
while(some set is changing) {//如果还有集合在变化则继续while循环，因文法是确定，最终循环可终止
    foreach (production p: N->β1 ... βn) {//遍历产生式规则p，p的格式左部N推出右边多个终结符和非终结符βi
        if (β1 == a ...)//如果β1是终结符a，则将终结符并入到集合中
            FIRST(N) ∪= {a}
        if (β1 == M ...)//如果β1是非终结符M，则将非终结符M的FIRST集并入集合中
            FIRST(N) ∪= FIRST(M)
    }
}
```

下边通过一个例子来说明上边算法，继续用上边N V N的文法。

```c
0: S -> N V N
1: N ->  s
2:     | t
3:     | g
4:     | w
5: V ->  e
6:     | d
```

结合下边循环次数表格，说明：

1. 进入程序，第0次循环，也就是初始化环节，都初始化为空集，对应表中第0列。进入循环前，isSetChange初始化true，随后进入循环。
2. 第1次循环，遍历每一条产生式，首先第0条S -> N V N，算法中β1指的就是右部第一个N，为非终结符，走第二个if，将N当前的FIRST集并入S，此时N的FIRST集是空集{}，所以S的也是空集{}。接下来是第1条产生式N -> s，是终结符，走第一个if，将s加入集合，变成{s, }，然后是第2条N -> t，同理加入t，得到{s, t}；其他的以此类推，最终得到{s, t, g, w}。N的所有产生式遍历完后，遍历到5条是V的，同理以此加入最终得到{e, d}。这一轮中，对比第0次，可看出N和V的集合发生了变化，故isSetChange依然为true。
3. 第2次循环，继续执行while循环内代码，遍历所有产生式，首先第0条S -> N V N，继续将N当前FIRST集并入S，故S的FIRST集变化为{s, t, g, w}；继续遍历后面的产生式时，N和V的集合都还是原来的，不用再添加，不用变化。这次执行，可见S的集合发生了变化，isSetChange依然为true。
4. 第3次循环，继续遍历所有产生式，此时S的FIRST集与N的一样了，无需再添加，N和V的也是，故本次没有集合发生变化，结束while循环。FIRST集产生完毕。

| N/FIRST | 0    | 第1次循环    | 第2次循环    | 第3次循环    |
| ------- | ---- | ------------ | ------------ | ------------ |
| S       | {}   | {}           | {s, t, g, w} | {s, t, g, w} |
| N       | {}   | {s, t, g, w} | {s, t, g, w} | {s, t, g, w} |
| V       | {}   | {e, d}       | {e, d}       | {e, d}       |

FIRST集的一般方式

```c
FISRT_S (β1 ... βn) = 
    FIRST(N), if β1 = N;//非终结符
    {a},      if β1 = a;//终结符
```

- **FIRST集作用**

作用就是用来构造LL(1)分析表。比如前边的例子里，可通过FIRST集获得分析表。

```c
文法：
0: S -> N V N //第0行
1: N ->  s
2:     | t
3:     | g
4:     | w
5: V ->  e
6:     | d
FIRST集：
    S: {s, t, g, w}
    N: {s, t, g, w}
    V: {e, d}
对应的LL(1)分析表:
N\T s t g w e d // 列是非终结符，行是终结符
 S  0 0 0 0     // 非终结符S右侧所有FIRST集元素对应的单元填入对应的文法第0行
 N  1 2 3 4     // 非终结符N右侧所有FIRST集元素对应的单元填入对应的文法第1~4行
 V          5 6 // 对应5~6行，都分别填入便得到了
```

- **LL(1)表的冲突**

如果LL(1)表一个表项存在多个可选值，称之为LL(1)表发生了冲突。冲突检测：对N的两条产生式规则N→β和N→γ，要求FIRST_S(β)和FIRST_S(γ)={*Ø*}。如下边例子里FIRST_S(w)∩FIRST_S(w V)={w} ≠ *Ø*，所以存在冲突。如果LL(1)表存在冲突，则说明该文法不是LL(1)文法，不能用LL(1)算法来分析。

```c
文法：
0: S -> N V N //第0行
1: N ->  s
2:     | t
3:     | g
4:     | w
5:     | w V
6: V ->  e
7:     | d
```



- **一般条件下的LL(1)分析表构造**

当下边例子存在推出空串的时候，就不能再用前边提到的求FIRST集的思路了，当空串出现时，需要进一步向后考虑。这就引入了NULLABLE这个集合记录有多少可推出空串，以及跟随集的概念。

```c
//文法
Z -> d
    | X Y Z
Y  -> c
    | 
X  -> Y
    | a

//1. 上边文法，可直接看出Z、Y、X的FIRST集分别是{d}、{c, 空}、{a}；
//2. 因为Y可为空，可为不存在，进一步推断出，X的可以是{a, c, 空}，然后Z的{d, a, c, 空};
//3. 因为X可以是空，既不用读入字符，栈弹出，如果为空，则应是Y的FIRST集，Y也可是空，则退为Z的；
//4. 所以Z->X Y Z的FIRST集当X为空不存在时，就等于Y的集，当Y也为空则为Z的。
```

NULLABLE：某个非终结符是否可推出空串。

跟随集（FOLLOW集）：某个非终结符后跟随什么符号。比如上边的Y，可推出空ε，当为空弹栈时，不需要输入字符（也未消耗字符），这时需考虑Y后边可以是什么字符，就是跟随集的概念。

- **NULLABLE集**

归纳定义：非终结符X属于NULLABLE集，当前仅当X -> 空ε，归纳情况X -> Y1 ... Yn（Y1 ... Yn是n个非终结符，且都属于NULLABLE集）。这里是Y，不是β，β代表可能是终结符也可能是终结符。简单来说NULLABLE集就是把所有可推出空串的左部的集合。求NULLABLE集的一般实现：

```c
NULLABLE = {};
while (NULLABLE is still changing){ //不动点算法
    foreach (production p: x->β) {
        if (β == ε) // ε表示空
            NULLABLE ∪= {X};
        if (β == Y1 ... Yn)
            if (Y1∈NULLABLE && ... && Yn∈NULLABLE)
                NULLABLE ∪= {X};
    }
}
```

下面以之前文法为例介绍算法思路

```c
//文法
Z -> d
    | X Y Z
Y  -> c
    | 
X  -> Y
    | a
```

| 循环次数   | 0    | 1      | 2      |
| ---------- | ---- | ------ | ------ |
| NULLABLE集 | {}   | {Y, X} | {Y, X} |

1. 初始化空集，进入while后，第一次循环，for遍历所有推导式，Z的两个推导式都进不了if里边，直到遍历到Y的第二个推导时可推出空ε，进入第一个if，将Y加入集合；继续遍历X->Y时，可进入第二个if，将X加入集合。这轮遍历结束。
2. 因NULLABLE集合从空集变化为{Y, X}，需要继续一次循环，继续遍历直至结束，无再添加的新的左部。结束循环。





- **FIRST集的完整计算公式**

有了前面介绍的NULLABLE集的结果，就可以利用这个集合计算出完整的FIRST集了，其归纳计算规则如下：

1. 基本情况：X -> a，FIRST(X) ∪= {a}
2. 归纳情况：X -> Y1 Y2 ... Yn，
   - FIRST( X ) ∪= FIRST( Y1 )
   - if  Y1 ∈ NULLABLE ,  FIRST( X ) ∪= FIRST( Y2 )
   - if  Y1, Y2 ∈ NULLABLE ,  FIRST( X ) ∪= FIRST( Y3 )
   - ...

其不动点算法实现如下：

```c
foreach (nonterminal N) //遍历所有非终结符N，初始化其对应的FIRST集为空集合
    FIRST(N) = {}
while(some set is changing) {//如果还有集合在变化则继续while循环，因文法是确定，最终循环可终止
    //遍历产生式规则p，p的格式左部N推出右边多个终结符和非终结符βi
    foreach (production p: N->β1 ... βn) {
        foreach (βi from β1 upto βn) { //遍历每一个右部
            if (β1 == a ...)//如果β1是终结符a，则将终结符并入到集合中
            	FIRST(N) ∪= {a};
            	break
        	if (β1 == M ...) {//如果β1是非终结符M，则将非终结符M的FIRST集并入集合中
            	FIRST(N) ∪= FIRST(M);
            	//若当前非终结符M不在NULLABLE中，说明不会推出空的情况，
                //则无需继续扩展FIRST(N)，结束for循环。
            	if (M is not in NULLABLE)
                	break;
            }
        }

    }
}
```

下面以之前文法为例介绍算法思路

```c
//文法
0 Z -> d
1     | X Y Z
2 Y  -> c
3    | 
4 X  -> Y
5     | a
```

| FIRST集\循环次数 | 0(初始化) | 1      | 2         |
| ---------------- | --------- | ------ | --------- |
| Z                | {}        | {d}    | {d, c, a} |
| Y                | {}        | {c}    | {c}       |
| X                | {}        | {c, a} | {c, a}    |

根据前一节产生的NULLABLE集={Y, X}，开始遍历

1. 初始化为空后，进入while第一次循环，遍历每一条文法，第0条时走第一个if把d加入到集合中得到{d}，然后break；接下来第1条时遍历每个右部{β1, β2, β3}对应{X, Y, Z}，首先X进入第二个if，把X={}（空集）并入还是{d}，因X在NULLABLE集，故还需考虑下一个Y，再把Y的FIRST集{}（也是空集）并入还是{d}，又因Y也在NULLABLE集，还需继续考虑Z，再把Z的FIRST集{d}并入则还是{d}，然后结束最里程遍历每个右部的for。继续遍历第2条产生式，得到Y得first集为{c}，第3条Y推出空ε，将空加入到集合还是{c}。遍历第4条将Y得FIRST集并入X得到{c}，因Y在NULLABLE集，但只有一个右部β1=Y，最里层for结束。遍历第5条将a加入到集合得到X的FIRST集{c, a}。第一轮while结束。
2. 因集合发生变化，继续第二轮while循环，继续第一个for循环遍历每一条产生式。首先第0条，已加d，不变。第1条，同样先并入X的FIRST集{c, a}，得到Z的FIRST集变为{d, c, a}，因X在NULLABLE集中，继续最里层for循环，遍历下一个Y，将Y的FIRST集{c}并入，还是{d, c, a}，同理继续Z，并入还是{d, c, a}，结束for。之后继续遍历其他产生式，同第一步过程，但集合均不再变化。结束第二次循环。
3. 因上一次Z的集合发生变化，继续while循环，重复前面描述的过程，遍历每一个产生式，但集合均未再发生变化，结束整个while循环，算法计算结束。

### FOLLOW集的不动点算法

FOLLOW集的计算算法如下描述。

```c
foreach (nonterminal N) //遍历所有非终结符N，初始化其对应的FOLLOW集为空集合
    FOLLOW(N) = {}
while(some set is changing) {//如果还有集合在变化则继续while循环，因文法是确定，最终循环可终止
    //遍历产生式规则p，p的格式左部N推出右边多个终结符和非终结符βi
    foreach (production p: N->β1 ... βn) {
        temp = FOLLOW(N);
        foreach (βi from βn downto βn) { //逆序 遍历每一个右部
            if (β1 == a ...)
            	temp = {a};
        	if (β1 == M ...) {
            	FOLLOW(N) ∪= temp;
            	if (M is not in NULLABLE)
                	temp = FIRST(M);
                else
                    temp ∪= FIRST(M);
            }
        }
    }
}
```

同样用上边的例子代入理解这个算法。

```c
//文法
0 Z -> d
1     | X Y Z
2 Y  -> c
3    | 
4 X  -> Y
5     | a
```

其中，NULLABLE={X, Y}，各个FIRST集如下表：

| 非终结符 | X      | Y    | Z         |
| -------- | ------ | ---- | --------- |
| FIRST集  | {a, c} | {c}  | {a, c, d} |

FOLLOW集的计算过程：

| FOLLOW集\循环次数 | 0(初始化) | 1         | 2         |
| ----------------- | --------- | --------- | --------- |
| Z                 | {}        | {}        | {}        |
| Y                 | {}        | {a, c, d} | {a, c, d} |
| X                 | {}        | {a, c, d} | {a, c, d} |

1. 初始化未空后开始第一次while循环，遍历各个产生式。

   - 首先第0行，temp=FOLLOW(Z)={}，然后 逆序遍历右部，只有一个d，走第一个if，使得temp={d}，不会再进入第二个if，结束最里层遍历右部的遍历，最终Z的FOLLOW保持{}（空集）。

   - 然后第1行，temp=FOLLOW(Z)={}，然后逆序遍历每个右部，从Z开始，进入第二个if，Z的FOLLOW(Z)并上temp={}还是空集；Z不在NULLABLE集合中，接下来走if分支，让temp=FIRST(Z)={a, c, d}。接下来下一个是Y，进入第二个if，Y的FOLLOW(Y)={}并上当前temp={a, c, d}，使得FOLLOW(Y)={a, c, d}，也即跟随在Y后的终结符可以是{a, c, d}里任意一个，因Y在NULLABLE集合中，之后走else分支，使得当前temp={a, c, d}并上Y的FIRST集{c}，得到temp还是{a, c, d}。接下来是X，也进入第二个if，使得FOLLOW(X)并上当前temp={a, c, d}后得到{a, c, d}，之后也进入else分支，temp集合不变，结束最里层for循环。
   - 继续遍历第2~5行，对Y的两个产生式，因为都只有一个右部，行为与第0行类似，不会进入第二个if，就结束了。第5行X->Y时，首先temp=FOLLOW(X)={a, c, d}，进入第二个if，FOLLOW(Y)并上当前temp不会产生变化，之后进入else分支，然后结束最里层for。最后一个产生式与前边一样，不会产生任何变化。

2. 因上一次集合发生变化，开始二次while循环，过程与第一次循环一样的，但集合不会产生新的变化，最后终止while循环。

### 计算产生式的FIRST_S集算法

有了每个非终结符的FIRST集、FOLLOW集，以及算法求出来的NULLABLE集，就可利用这些算出每个产生式的FIRST集（为加以区分，叫做FIRST_S(P)），用于填充算出LL(1)分析表，类似与最开始介绍FIRST集作用时一样，得到LL(1)分析表用于分析语法。这个算法如以下代码所示。

```c
foreach (production p)
    FIRST_S(P) = {}
CalculateFIRST_S (production p: N->β1 ... βn) {//参数是一个产生式
    foreach (βi from β1 to βn) {
        if (βi == a ...) {// 如果产生式第一个右部是终结符a
            FIRST_S(P) ∪= {a};// FIRST集并上a，计算结束，返回
            return;
        }
        if (βi == M ...) {// 如果产生式右部是非终结符
            FIRST_S(P) ∪= FIRST(M);// 则并上该非终结符的FIRST集
            if (M is not in NULLABLE)// 如果M不在NULLABLE集合内
                return;// 说明M不会产生空ε，不用再考虑为空的情况，直接返回
        }//但如果在NULLABLE集合则可能是空，则需要将下一个右部的FIRST集并进来
    }
    //如果所有右部都遍历完了，且都可能产生空，则要把当前左部N的FOLLOW集并入
    //意思就是当前N右部都为空ε，当前产生式的FIRST集则需看哪些终结符可能跟随在当前左部非终结符之后。
    //当前N是空的时候，就可以紧跟其后的终结符开头，所以要并FLLOW集。
    FIRST_S(P) ∪= FOLLOW(N);
}
```

下面继续以之前的文法为例子理解该算法。

```c
//文法
0 Z -> d
1     | X Y Z
2 Y  -> c
3    | 
4 X  -> Y
5     | a
```

其中，NULLABLE={X, Y}，各个FIRST集如下表：

| 非终结符 | X         | Y         | Z         |
| -------- | --------- | --------- | --------- |
| FIRST集  | {a, c}    | {c}       | {a, c, d} |
| FOLLOW集 | {a, c, d} | {a, c, d} | {}        |

计算出FIRST_S的结果过程：

| 文法编号  | 0    | 1         | 2    | 3         | 4         | 5    |
| --------- | ---- | --------- | ---- | --------- | --------- | ---- |
| FIRST_S集 | {d}  | {a, c, d} | {c}  | {a, c, d} | {a, c, d} | {a}  |

1. 首先第0条产生式，左边是非终结符Z，右边是终结符d，故进入算法后，走第一个if，将d加入后返回结束。
2. 第1条右边是X Y Z，进入函数后走第二个if，将X的FIRST集{a, c}并入，得到{a, c}；因X在NULLABLE，需要遍历下一个Y，将FIRST(Y)={c}并入后得到{a, c}；又Y也在NULLABLE集合，继续遍历到Z，将FIRST(Z)={a, c, d}并入后得到第1条产生式的FIRST_S集是{a, c, d}；因Z不在NULLABLE，返回结束。
3. 第2条Y->c与第0条一样的，将c加入后返回结束。第3条右边是空，两个if都不会进入，然后结束for循环，进入FIRST_S(P) ∪= FOLLOW(N)，意思就是看当Y=空ε时，有哪些终结符能够跟在Y=空ε后边，显然a、c、d都有可能，所以拿到Y的FOLLOW集（就是表示有哪些终结符可能跟随在Y之后）并入，得到{a, c, d}。
4. 第4条，显然进入第二个if，将FIRST(Y)={c}并入得到{c}，又因Y在NULLABLE集内，继续for循环，因只有一个右部Y，结束for，执行最后一句FIRST_S(P) ∪= FOLLOW(N)，同样的道理，把X的FOLLOW集={a, c, d}并入，最终得到{a, c, d}，计算结束。第5条进入第一个if，得到{a}，返回结束。

### 构造LL(1)分析表

继续用前边文法作为例子，构造LL(1)分析表。

```c
//文法
0 Z -> d
1     | X Y Z
2 Y  -> c
3    | 
4 X  -> Y
5     | a
```

FIRST_S集表

| 文法编号  | 0    | 1         | 2    | 3         | 4         | 5    |
| --------- | ---- | --------- | ---- | --------- | --------- | ---- |
| FIRST_S集 | {d}  | {a, c, d} | {c}  | {a, c, d} | {a, c, d} | {a}  |

LL(1)分析表由非终结符和终结符构造出一张二维表格，两者交叉的单元格内，根据FIRST_S集成员填入文法编号。

**填表过程：**

- 首先第0条产生式，左边是Z，对应Z行，然后看对应右边能够出现的终结符（对应FIRST_S集），只有d，故在d列下填0。
- 然后第1条产生式，左边也是Z，右边全是非终结符，对应能推导出的终结符（对应FIRST_S集）有{a, c, d}，则在a、c、d下都填入1。
- 比较特别的是第3条，右边是空，根据求出的FIRST_S集，也能填出对应的表项，其他文法也一样，依次填入即可。

| 非终结符/终结符 | a    | c    | d    |
| --------------- | ---- | ---- | ---- |
| Z               | 1    | 1    | 0, 1 |
| Y               | 3    | 2, 3 | 3    |
| X               | 4, 5 | 4    | 4    |

LL(1)分析表构造出来后，就可用于算法了，根据当前的非终结符和前看符号，查找对应的表项的值，比如出现Z和前看a时，对应的就是第1条文法，如果表中查不到或者表项标注是错误，则可直接报错了，说明当前读入的字符就是不合法的了，语法错误。另外，可看出，上边表格一个表项存在多个值，也就是可对应多条文法，显然是不能用的，若使用这表格显然又要每个值尝试一遍，这种有多个值的情况就是表冲突，之后章节将进一步说明。

### LL(1)分析器驱动算法

根据最开始介绍的LL(1)算法的框架，首先输入的是文法，用前边几节介绍的算法作为语法分析模块，将文法转换成LL(1)分析表。之后读入tokens流，根据分析表，利用驱动算法作为语法分析器，就可分析读入的语法正确与否了。而LL(1)分析器改造于通用的自顶向下分析算法，如下文所示：

```c
tokens[]; 
i = 0; 
stack = [E];
while (stack != []) {
    if (stack[top] is a terminal t) 
        if (t == tokens[i++])
            pop();
    	else
            Error("..."); //不匹配，直接报错，不用回溯，因为每次入栈的都是正确的，不匹配即不正确
    else if (stack[top] is a non-terminal T) {//如果不是终结符
        pop();// 则弹出该元素
        //入栈的规则是查LL(1)分析表，根据当前非终结符和当前符号tokens[i]（终结符）查找表项，找出应选第几条文法
        push(table[T, tokens[i]]);
    }
}
```

最重要的变化就是查LL(1)分析表，以确定是选哪条文法，然后把该文法的右部自左向右压入栈中，之后进行终结符比较，如果不匹配就可报错了，说明当前输入的终结符和栈中存有的右部不匹配。其实也可看出，简单语法的时候，在使用前看符号查表的过程中，也可能会获得一条无效文法编号索引，也就可直接报错了。

### LL(1)分析表冲突

前边例子中产生的LL(1)分析表是有冲突的，也就是说该文法无法使用LL(1）算法来分析。当然实际工程中，多因文法构造不合理，或者可通过改造文法格式的方式来消除冲突，但往往改造后的文法变得晦涩难懂了。

​    比如之前的算术表达式的文法，通过文法很容易看出其结合性和优先级（也就是可读性更好）。这个文法构造出的LL(1)分析表如下文代码中所示，因为E和T都有左递归的存在，分析表可选择的文法规则可以是两条。

> 所谓**左递归**，比如E，可选0和1两条，选择0时，推出E+T，右边又出现E，继续选择E的产生式，如果继续尝试第0条，则变成E+T+T，以此类推，左边可无限扩展。

```c
//文法G
0 E -> E + T
1     | T
2 T  -> T * F
3     | F
4 F  -> n

//FIRST_S集
           0   1   2   3   4
FIRST_S集 {n} {n} {n} {n} {n}

//LL(1)分析表
   n    +  *
E  0,1
T  2,3
F  4
```

可见，冲突的根本原因是因左递归的存在，所以学术界提出解决办法是**消除左递归**，重新构造文法。（可见，任何有左递归的文法都不是LL(1)，都不能用LL(1)来分析）。

​    比如上文提到的左递归过程，当遇到E时，可以根据第0条产生E+T+T+T，接下来走第1条最终得到T+T+T+T，可见第一个是T是走的第1条文法，之后的都是第0条文法。那就可转换为，E可产生一个T，以及0个或者无限个+T，即可对+T进行一次抽象提取，变成E可推出T E'，而E'可产生0或多个+T、空ε 两条文法，如下文文法0~2行所示，就转换成了右递归了。之后的T的两条文法也同理可进行改造扩展，最终得到如下文法：

```c
//文法
0 E   -> T E'
1 E'  -> +T E'
2      | ε
3 T   -> F T'
4 T'  -> *F T'
5      | ε
6 F  -> n

//改造后得到的LL(1)分析表
   n    +   *
E  0
E'      1
T  3
T'      5   4
F  6
```

另一种办法是提取左公因子，如下文法例子所示：

```c
X   -> a Y
     | a Z
Y   -> b
Z   -> c

//改造后
X   -> a X'
X'  -> Y
     | Z
Y   -> b
Z   -> c
```

## LR(0)分析算法

自底向上分析算法，是最重要最广泛应用的一类。是LR分析算法（移进-归约算法），具有运行高效、有工具可用、无需改写文法的特点。目前广泛应用的算法，被自动生成器中如YACC、bison、CUP、C#yacc等采用。下边通过之前的算数表达式的文法作为例子，来介绍算法的思想。

​    核心思想是**规约**，就是看到输入字符后，看能不能找到一个产生式与之对应，不断用左部替换，直至替换成起始符号S，找到对应右部，用左部替换的过程称之为规约。

```c
0 S  -> E
1 E  -> E + T
2     | T
3 T  -> T * F
4     | F
5 F  -> n

//归约过程
2 + 3 * 4 首先拿到这样一个表达式，读入第一个字符2。
F + 3 * 4 查看文法，可看出第5条文法的右部n与之匹配，进行归约，用左部F替换。
T + 3 * 4 继续可看出T可进一步归约成T，用T替换F。
E + 3 * 4 然后发现T又可归约成E，可能有为何E不进一步归约成S等疑惑，后面会详解。
E + F * 4 继续读入+，再读入3，可看出3可归约成F。
E + T * 4 F进一步归约成T，这里T也不进一步归约成E了。
E + T * F 之后再读入*，读入4，归约成F。
E + T     可看出T * F满足文法3，归约成T。
E         E + T又满足文法1，整个归约成E。
S         最后E归约成S，也就是开始符号
```

可见上边的推导过程，从下往上看，是最右推导，总是替换最右侧的非终结符。而从上往下看，也就是这个算法的推导思想是最右推导的逆过程。

点记号“·”：用于分割分析器已读入和未读入的字符。

核心是移进、归约，生成一个逆序的最右推导：

- 移进：移进一个记号到栈顶。（读入字符，向后移动记号点·的过程）。
- 归约：栈顶上n个符号（某个产生式的右部）替换成左部非终结符的过程。比如A->β1...βn，若βn...β1在栈顶，则弹出βn...β1，压入A。

**算法思想**

算法的核心是移进、归约的时机，其思路可通过之后例子详细描述。下文是一个推到出xxy字符串的文法

```c
//文法→xxy
0 s' -> S
1 S  -> xxT
2 T  -> y
```

![转移图](http://tva1.sinaimg.cn/large/d0043e63gy1h6fusjts3yj20t406ejsi.jpg)

当输入串是xxy时

# IR



# 编译优化



# X86后端

## X86指令

![image](https://github.com/00lab/osPrj/assets/9030950/f96cd4e6-e920-42eb-8816-ecf678a97c9f)

![image-20230702005055420](https://gitee.com/shengbao/images/raw/master/image-20230702005055420.png)

x86采用不定长指令编码，正常的x86指令长度最短为1个字节，最长为15个字节。含指令前缀（Instruction Prefix，提供附加功能）、操作码（Opcode）、ModR/M字段、SIB字段、偏移（Displacement）和立即数（Immediate）。ModR/M和SIB字段一般提供操作数的访问模式。

### 指令前缀

1. 操作数大小重写前缀

   二进制编码 0x66。用于指令操作数大小与当前汇编上下文默认操作数大小不一致的情况。用于16位汇编强制访问32位寄存器，或32位汇编语言访问16位寄存器。

   32位汇编语言指令”mov eax, 1“，指令编码b8 01 00 00 00。16位汇编语言中不能直接访问寄存器eax，变成“mov ax，1”，如果要要访问32位寄存器eax，必须使用前缀修改操作数大小，66 b8 01 00 00 00。以强制访问32位寄存器eax。

2. 地址大小重写前缀

   二进制编码为0x67。用在指令内存操作数地址大小与当前汇编上下文默认地址大小不一致的情况。

   32位汇编语言指令“mov eax，[0x12345678]”，指令编码a1 78 56 34 12。16位汇编语言中，不能直接访问32位地址，指令被截断a1 78 56，变成“mov ax，[0x5678]”，如要强访32位地址，则改成67 a1 78 56 34 12。也适合32位强访16位地址。

3. 段重写前缀

   如果要修改指令内存操作数的段寄存器，则需要使用段重写前缀。不同段寄存器对应指令前缀的二进制编码如下：

   ![image](https://github.com/00lab/osPrj/assets/9030950/de61ddf2-a0aa-4da0-adb3-f3b97db189da)

   ![image-20230702005406795](https://gitee.com/shengbao/images/raw/master/image-20230702005406795.png)

   如mov eax，[ebx]，该指令使用ebx寄存器间址访问内存，默认当前段寄存器为数据段寄存器ds。如果需要指定段寄存器为es，需改为mov eax，es：[ebx]，对应指令编码 26 89 03 。

   在32位内存模式下，对内存操作数的段重写已经失去意义。无论是为内存操作数指定段寄存器还是指定不同的段寄存器，都不会影响指令的功能。

4. 重复执行指令前缀

   包括rep/repz和repnz指令前缀，对应的二进制编码分别为0xf3和0xf2。该类指令一般用于串操作指令。如“rep movsb”，指令编码“f3 a4”。

5. lock前缀

   二进制编码为0xf0。该指令用于指令执行时锁定地址总线，保证对称多处理器（SMP）环境下对内存数据访问的原子性。

   如“lock add eax，[ebx]”，指令编码f0 01 03 。

6. 分支提示前缀

   分支提示前缀仅用于条件跳转指令Jcc，表示条件跳转在大多数情况下是否发生。前缀ht表示Jcc指令大多数情况跳转成功，二进制编码为0x3e，前缀hnt表示Jcc指令大多数情况不发生跳转，二进制编码为0x2e。如“hnt jne L”，表示jne指令大多数情况不会跳转到L，指令编码：2e 0f 85 00 00 00 00，

以上是传统的x86指令前缀，在AMD推出x86扩展64位技术之后，增加了新的用于访问64位数据的指令前缀（REX prefix），而原本的x86指令前缀称为原始前缀（Legacy prefix）。因此64位汇编指令可以使用这两类指令前缀，而32位汇编指令仅能使用Legacy前缀。

### 操作码

如mov这些指令，表示指令的功能，不可缺，1-3字节。

- 因为指令前缀可选，1字节操作码与指令前缀共享指令第一个字节的空间（0x00—0xff），CPU的解码器根据指令第一个字节的值确定该字节是指令前缀还是操作码。如遇0x66，则为OP大小重写前缀，若为0xb8则为mov指令。
- 2字节操作码总是以0x0f开始，紧跟另一个字节。0x0f字节称为操作码的转义前缀（Escape Prefix）或转义操作码。如jne指令的操作码为“0f 85“。
- 3字节操作码也是使用转义前缀的方式进行扩展编码。3字节操作码的转义前缀包含“0f 38”和“0f 3a”两种，转义前缀后紧跟另一个字节共同表示操作码。



以下只讨论1字节和2字节操作码，据功能分以下四类：

1. 操作码独立表示指令功能

    ![image-20230701180101144](https://gitee.com/shengbao/images/raw/master/image-20230701180101144.png)

   条件跳转指令（Jcc）的jne指令，操作码“0f 85”后紧跟4字节的目标标签的相对地址。类似的指令包括Jcc、jmp、call、int、push，其中rel32表示32位相对地址，imm8表示8位立即数，imm32表示32位立即数。

2. 组属性操作码，ModR/M和SIB字段仅指定操作数访问模式

   这类操作码仅定义了指令的基本框架，并未明确具体的操作数，具体的操作数由ModR/M和SIB字段给出。

   ![image-20230702005812744](https://gitee.com/shengbao/images/raw/master/image-20230702005812744.png)

   其中r32表示32位寄存器，r/m32表示32位寄存器或内存操作数。“mov r32，r/m32”的操作码0x8b仅表示该指令可以从32位寄存器或内存中取出数据保存到32位寄存器中，但并未说明具体是哪个寄存器和内存地址。而ModR/M和SIB字段提供了这样的信息。

3. 组属性操作码，ModR/M的reg字段对操作码作补充

   ModR/M字节的3～5位表示reg字段，取值范围为0～7，该字段可以对组属性的操作码进行补充。表5-4操作码列中的“/”符号后的数字表示reg字段的值，例如imul和idiv指令的操作码都是0xf7，当reg=5时表示imul指令，当reg=7时表示idiv指令。

   ![image-20230702010545027](https://gitee.com/shengbao/images/raw/master/image-20230702010545027.png)

   ![image-20230702010637443](https://gitee.com/shengbao/images/raw/master/image-20230702010637443.png)

4. 组属性操作码，寄存器编号补充操作码

   inc指令的组属性操作码为0x40，当指定了具体的操作数寄存器后，需要将该寄存器的编号累加到操作码中，类似的指令还有dec、push、pop、mov等。

   ![image-20230702010900018](https://gitee.com/shengbao/images/raw/master/image-20230702010900018.png)

   Intel指令集中的寄存器编号都是固定的，常见的寄存器编号：

   ![image-20230702012153293](https://gitee.com/shengbao/images/raw/master/image-20230702012153293.png)

   注：通用寄存器的eax、ebx、ecx、edx的编号并不是按照名字递增的顺序编号，而是被分别编号为0、3、1、2。

### ModR/M字段

| 7-6（2Bit） | 5-3（3Bit） | 2-0（3Bit） |
| :---------: | :---------: | :---------: |
|     mod     | reg/opcode  |     r/m     |

reg字段保存寄存器编号或操作码的补充信息。

r/m字段表示另一个操作数，也保存寄存器编号，该编号指定的寄存器中可能是操作数本身，也可能是存放与操作数的内存地址相关的信息。

mod字段为r/m字段指定具体的操作数模式，r/m字段内保存寄存器编号，根据不同mod的值确定该寄存器是寄存器操作数，还是需要寻址的内存操作数。

![image-20230702012915091](https://gitee.com/shengbao/images/raw/master/image-20230702012915091.png)

例如

1）0x8b表示指令“mov r32，r/m32”的操作码，其中r32对应reg字段，r/m32对应r/m字段。由此指令“mov ecx，eax”的编码为：8b c8
其中，0xc8为ModR/M字段的值，表示为二进制形式为：11 001 000
可以看出mod=0b11，表示r/m字段为寄存器操作数。reg=0b001，表示mov指令的操作数r32=ecx。r/m=0b000，表示mov指令的另一个操作数r/m32=eax。因此，二进制编码“8b c8”表达了汇编指令“mov ecx，eax”的完整信息。

2）指令“mov ecx，[eax]”的ModR/M的mod字段为0b00，指令编码为：8b 08 (00 001 000, 00 ecx eax)。

3）指令“mov ecx，[eax+4]”的ModR/M的mod字段为0b01，表示r/m字段为寄存器基址+8位偏移寻址。需要增加1字节的偏移字段0x04。指令编码为：8b 48 04。

4）指令“mov ecx，[eax+0x12345678]”的ModR/M的mod字段为0b10，表示r/m字段为寄存器基址+32位偏移寻址。需要增加4字节的偏移字段0x12345678。指令编码为：8b 88 78 56 34 12。

注：指令中编码的偏移或立即数，都是按照小端字节序（Little Endian）的方式存储的，即高字节数据存储在高地址，低字节数据存储在低地址。因此偏移“0x12345678”存储形式为“78563412”，而非“12345678”。

上述仅含：寄存器寻址（寄存器操作数）、寄存器间址、寄存器基址+偏移寻址

还有：立即寻址（立即数操作数）、直接寻址（直接使用内存地址寻址）、寄存器基址+寄存器变址+偏移寻址

5）立即寻址：Intel x86指令集的立即数一般都是硬编码在指令内部，而不需要ModR/M字段指定。指令“mov r32，imm32”，其操作码为0xb8+reg，对于“mov ecx，0x12345678”，其中reg保存ecx的寄存器编号0b001，其指令编码为：b9   78 56 34 12。

6）直接寻址：Intel x86指令集规定，当mod=0b00，r/m=0b101时，表示32位直接寻址模式。例如指令“mov ecx，[0x12345678]”，其指令编码为：8b 0d   78 56 34 12。

​    而0b101是寄存器ebp的编号，由于该编号被直接寻址模式占用，因此形如“mov r32，[ebp]”的指令，必须转化为“mov r32，[ebp+0]”进行处理。例如指令“mov ecx，[ebp]”的指令编码为：8b 4d 0。使用[ebp]寻址的指令需要额外使用1字节的存储。

7）寄存器基址+寄存器变址+偏移寻址：Intel指令集规定，当mod！=0b11，r/m=0b100时，表示引导SIB字段。由SIB字段表示ModR/M字段无法表示的寻址模式，而mod定义的偏移信息仍然有效。由于引导SIB字段占用了寄存器编号0b100，对应寄存器esp。因此形如“mov r32，[esp]”“mov r32，[esp+disp8]”“mov r32，[esp+disp32]”的指令也无法仅使用ModR/M字段表示。

![image-20230702231615142](https://gitee.com/shengbao/images/raw/master/image-20230702231615142.png)

### SIB字段

SIB字段（一字节）为ModR/M字段补充寻址模式，通用寻址模式为寄存器基址+寄存器变址+偏移的寻址，当然也解决了上述由于寄存器编号冲突导致的部分指令无法由ModR/M字段表示的问题。

| sib字段：  |            |            |
| ---------- | ---------- | ---------- |
| 7-6 (2bit) | 5-3 (3bit) | 2-0 (3bit) |
| scale      | index      | base       |

base字段保存基址寄存器的编号，index字段保存变址寄存器的编号，scale字段保存以2为底的指数，表示变址寄存器的因子。SIB字段定义的寻址模式格式为：[base + index * 2^scale] （2的scale次方）

![image-20230702232237766](https://gitee.com/shengbao/images/raw/master/image-20230702232237766.png)

如指令“mov ecx，[eax+ebx]”中，内存操作数使用了变址寄存器ebx（当然，也可以将eax看作变址寄存器），因此必须使用SIB字段辅助寻址。指令编码为：8b 0c 18。

- 其中0x0c为ModR/M字段，二进制编码为00001100。mod=0b00表示指令不存在偏移，reg=0b001表示操作数ecx，r/m=0b100表示引导SIB字段。
- 0x18为SIB字段，二进制编码为00011000。scale=0b00表示变址寄存器因子为2^0=1，index=0b011表示变址寄存器ebx，scale=0b000表示基址寄存器eax。因此，使用ModR/M和SIB字段完整表达了指令的功能。

指令“mov ecx，[eax+ebx*8+0x12345678]”，指令编码为：8b 8c d8 78 56 34 12。其中ModR/M的字段mod=0b10表示指令中存在32位偏移，而SIB的字段scale=0b11，表示变址寄存器因子为23=8，32位偏移仍按照小端字节顺序的方式存储。

SIB寻址模式：

![image-20230702232726410](https://gitee.com/shengbao/images/raw/master/image-20230702232726410.png)

## AT&T语法

x86汇编语法两种常见格式：Intel汇编语法和AT&T汇编语法。Intel汇编语法常见于Intel官方文档和Windows平台，AT&T汇编语法常用于Unix/linux平台。一般使用NASM汇编Intel格式的汇编程序，而使用as汇编AT&T格式的汇编程序。

![image-20230705010129790](https://gitee.com/shengbao/images/raw/master/image-20230705010129790.png)

- AT&T汇编的寄存器操作数前需要添加前缀“％”，立即数操作数需要添加前缀“$”。

- 两种汇编最大的不同是操作数位置相反，Intel汇编指令形式为“助记符  目的操作数，源操作数”，而AT&T汇编指令形式为“助记符  源操作数，目的操作数”。

- 内存操作数，其一般的Intel汇编形式为“section：[base+index*scale+disp]”，而AT&T汇编形式为“％section：disp（％base，％index，scale）”。段寄存器section、基址寄存器base、变址寄存器index、变址寄存器因子scale、偏移disp都是可选的。当不存在基址寄存器base时，仍需要保留逗号分隔符。当不存在偏移disp时，默认为1。当仅有偏移disp时，表示直接寻址操作数，Intel汇编使用“[]”将内存地址包含起来，而AT&T直接使用内存地址进行访问。

  ![image-20230705010601244](https://gitee.com/shengbao/images/raw/master/image-20230705010601244.png)

  ![image-20230705010637324](https://gitee.com/shengbao/images/raw/master/image-20230705010637324.png)

- 内存操作数都是通过寻址的方式进行访问的，操作数的大小一般可以通过源寄存器或目的寄存器的大小自动推断。当内存操作数大小无法自动推断时（比如操作数中不存在寄存器时），必须显示指定操作数的大小：

  ![image-20230705011030591](https://gitee.com/shengbao/images/raw/master/image-20230705011030591.png)

  Intel汇编使用“byte/word/dword ptr”前缀修饰内存操作数，表示操作数的大小是1、2、4字节。而AT&T则是通过在操作码后添加后缀“b/w/l”进行表示，分别对应单词“byte/word/long”。

- 内存操作数被作为数据对待，但是内存操作数被作为地址对待时，情况比较特殊，特殊内存操作数：

  ![image-20230705011304241](https://gitee.com/shengbao/images/raw/master/image-20230705011304241.png)

  当内存操作数作为跳转类指令（call、jmp、Jcc等）的目标地址时，需要使用前缀“\*”修饰内存操作数。例如指令“jmp 0x1234”表示跳转到地址0x1234处执行，而指令“jmp*0x1234”表示将地址0x1234处的内存数据取出，作为跳转地址。

- 汇编数据定义格式：

  ![image-20230705011621420](https://gitee.com/shengbao/images/raw/master/image-20230705011621420.png)

  ![image-20230705011650372](https://gitee.com/shengbao/images/raw/master/image-20230705011650372.png)

  Intel汇编使用“db/dw/dd”定义数据的长度，而AT&T使用“.byte/.word/.long”定义数据长度。Intel汇编使用“times”定义一块连续内存，而AT&T使用“.fill”定义连续内存。Intel汇编使用db后紧跟逗号分隔的常量列表定义字符串，而AT&T使用.ascii定义字符串。

- 指令：nasm -f elf filename.s 、as filename.s –o filename.o

## ELF文件

# ARM后端



# 链接器linker



# LLVM



# JDK





# 

# 编程基础

## C/C++中的强符号和弱符号

先看如下场景

```c
// 在1.c中定义了全局变量
int g = 1;
int g2;
```

同时

```c
// 在2.c中也定义了全局变量
int g = 1;
double g2;
```

对上边C文件编译时会报**符号重复定义（Multiple Definition）**的错误，这是因为在多个源文件中定义了同名的全局变量，且都已初始化。报错如下

```shell
2.o: multiple definition of `g'
1.o: first defined here
```

在C中，默认情况下，编译器认为函数和已初始化的全局变量为强符号（Strong Symbol），未初始化的全局变量为弱符号（Weak Symbol）。强符号是因拥有已确定的初始化数据，变量有值，函数有函数体；弱符号则是因符号还未被初始化，无确定数据，只是个声明。

链接器对重复定义变量（强/弱符号）的处理规则：

1. 不能定义多个强符号，即不同.o目标文件里变量/函数不能重复定义，若有多个同名强符号，链接器报符号重定义的错误。
2. 若一符号在其中一个目标文件中是强符号，其他是弱符号（如只声明，无初始化），则选择强符号。
3. 若一符号在所有目标文件中都是弱符号，则选占内存空间最大的一个。如上边例子的g2会占8字节，可见若出问题则很难排查。(此点参考其他博客资料，最新编译器验证是不成立的，见下文例子)

特注：上边第3点在实测中不一定对，用sizeof会是本文件变量的内存大小。

```c
//gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)
// main.c
#include<stdio.h>
int w2;
int main() {
        printf("sizeof(w2)=%ld in main.c", sizeof(w2));
        func();
        return 0;
}

//test.c
#include<stdio.h>
double w2;
void func() {
        printf("sizeof(w2)=%ld in test.c\n", sizeof(w2));
}
//编译 gcc main.c test.c
//运行结果：
sizeof(w2)=4 in main.c
sizeof(w2)=8 in test.c
//同样这个例子，用g++编译的话，则会报重复定义的错误了
/tmp/ccqUe8kE.o:(.bss+0x0): `w2'被多次定义
/tmp/cczTldSS.o:(.bss+0x0)：第一次在此定义
collect2: error: ld returned 1 exit status
```

使用gcc编译，可用\__attribute__((weak))强制定义一符号为弱符号，可用于解决重复定义的报错（用于调试用，实际工程还是别这么干了）。见如下例子：

```c
extern int e1; //引用外部变量，非强符号也非弱符号，作用是告诉编译器别报未定义，这个变量在链接时能找到。

int w1;//弱符号
__attribute__((weak)) int w2 = 1; //弱符号
__attribute__((weak)) void func() { //弱符号，如果func函数在其他地方也被定义了，不加__attribute__((weak))会报Multiple Definition错误
    printf("弱符号函数");
}
int s1 = 1;//强符号
void main() {
    printf("强符号");
}
```

弱符号主要用于解决一些库的冲突或引入一些库，防止符号冲突。再看个上面列的第二规则的例子（注意是两个c文件）:

```c
//gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)
//以下内容是test.c内容
#include<stdio.h>
int w1 = 2;
void func() {
        printf("weak symb =func in test\n");
}
//以下是main.c内容
#include<stdio.h>
__attribute__((weak)) int w1 = 1;
__attribute__((weak)) void func() {
        printf("weak symb =func in main\n");
}
int main() {
        printf("w1=%d\n", w1);
        func();
        return 0;
}
//编译： gcc main.c test.c 运行结果，打印出强符号的值 （g++ main.c test.c编译的结果也一致）
w1=2
weak symb =func in test
```

当然，\__attribute__((weak))只对链接器有效，对编译器无效，在编译器没有强/弱符号之分，如在同一文件内，定义两个同名变量，则报重复定义错误，如例子

```c
#include<stdio.h>
__attribute__((weak)) int w1 = 1;
int w1 = 2;
int main() {
        printf("w1=%d\n", w1);
        return 0;
}
//编译gcc test_sam.c
error: redefinition of ‘w1’
 int w1 = 2;
     ^~
note: previous definition of ‘w1’ was here
 __attribute__((weak)) int w1 = 1;
```



## C/C++拷贝文件



```c
UINT32 CpServiceFileToEtcHguardDir(CHAR *srcDir, CHAR *fileName, int serviceFlagLen, CHAR *serviceCmd)
{
    CHAR srcPath [128] = {0};
    snprintf_s(srcPath, sizeof(srcPath), sizeof(srcPath) - 1, "%s%s", srcDir, fileName);
    CHAR dstPath [128] = {0};
    snprintf_s(dstPath, sizeof(dstPath), sizeof(dstPath) - 1, "%s%s", ETC_HGUARD_D_DIR, fileName);

    int fdDst = open(dstPath, O_RDWR | O_CREAT, S_IRUSR | S_IRGRP);
    if (fdDst == -1) {
        syslog(LOG_ERR, "[sys_boot]create fileName=%s in %s unsuccessful", fileName, ETC_HGUARD_D_DIR);
        return VOS_ERROR;
    }

    FILE *fpSrc = fopen(srcPath, "r");
    if (fpSrc == NULL) {
        syslog(LOG_ERR, "[sys_boot]open fileName=%s in %s unsuccessful", fileName, srcDir);
        return VOS_ERROR;
    }

    CHAR buf[1024] = {0};
    while(1) {
        int op = fread(buf, 1, 1024, fpSrc);

        if (op <= 0) break;
        write(fdDst, buf, op);
    }
    fclose(fpSrc);
    close(fdDst);
    CHAR packageVersion[PACKAGE_VERSION_LINE_SIZE] = {0};
    UINT32 ret = GetPackageVersion(packageVersion);
    if (ret != VOS_OK) {
        syslog(LOG_ERR, "[sys_boot]get package version unsuccessful");
    }

    // 提取service名字
    int nameEndInd = strlen(fileName) - serviceFlagLen;
    snprintf_s(buf, nameEndInd + 1, nameEndInd, "%s", fileName);

    buf[nameEndInd] = '\0';
    FILE *fpDst = fopen(dstPath, "a");

    if (strcmp(fileName, "capacityset.service") == 0 || strcmp(fileName, "schema_loader.service") == 0) {
        fprintf(fpDst, "\n\nEnvironment=HW_SERVICE_TYPE=%s\nEnvironment=HW_PACKAGE_VERSION=%s\nExecStop=+/usr/local/bin/service_stop_proc.sh > /dev/null 2>&1\nExecStopPost=+/usr/local/bin/service_status_handler.sh 1 > /dev/null 2>&1\n",
        buf, packageVersion);
    } else {
        fprintf(fpDst, "\n\nEnvironment=HW_SERVICE_TYPE=%s\nEnvironment=HW_PACKAGE_VERSION=%s\nExecStop=+/usr/local/bin/service_stop_proc.sh > /dev/null 2>&1\nExecStopPost=+/usr/local/bin/service_status_handler.sh 1 > /dev/null 2>&1\nConditionPathExists=/var/run/nctld.path\n",
        buf, packageVersion);
        strcat(serviceCmd, " ");
        strcat(serviceCmd, fileName);
    }
    fclose(fpDst);
    return VOS_OK;
}
```

## C 多线程模型



## c++ 特殊函数：=default 和 =delete

在C++中，声明自定义的类型(class A )之后，编译器会默认生成一些成员函数，这些函数被称为**默认函数**

【（默认）构造函数】、【拷贝（复制）构造函数】、【拷贝（复制）赋值运算符】、【移动构造函数】、【移动赋值运算】、【符析构函数】

另外，编译器还会默认生成一些**操作符函数**，包括

【operator ,】【operator &】【operator &&】【operator *】【operator ->】【operator ->*】【operator new】【operator delete】

### 1.（=default）补充默认函数（显式缺省函数）

```text
#include <iostream>
using namespace std;

class Test
{
public:
    Test() = default;  // 显式指定缺省函数 (补充默认构造函数)
    Test(int i) : data(i) {}

private:
    int data;
};

int main()
{
    std::cout << std::is_pod<Test>::value << std::endl;  // 1
}
```

C++11中提供了新的机制来控制默认函数生成来避免这个问题：声明时在函数末尾加上”= default”来显式地指示编译器去生成该函数的默认版本。

### 2.（=delete）删除默认函数（显式删除函数）

```text
#include <iostream>
using namespace std;

class Test
{
public:
    Test() = default;  // 显式指定缺省函数
    Test(int i) : data(i) {}
    Test(const Test& t) = delete; // 显式删除拷贝构造函数

private:
    int data;
};

int main()
{
    Test objT1;
    Test objT2(objT1); // 无法通过编译
}
```

禁止拷贝构造函数的使用, 在C++11中，只要在函数的定义或者声明后面加上”= delete”就能实现这样的效果（相比较，这种方式不容易犯错，且更容易理解）。

### 3.其他方面：（= default）和（= delete）

**3.1 (= default)类外使用**

**(= default)能在类外的定义中修饰成员函数,**能够为一个类实现多个版本，只要我们在头文件里声明同样的函数，而在不同的cpp文件中用不同的方法实现，当选择不同的cpp编译时产生的版本就不同。

```text
class Example
{
public:
    Example() = default;
    Example(const Example&);

private:
    int data;
};

Example::Example(const Example& ex) = default; //类外使用
```

***注：default只能用于6个特殊成员函数，但delete可用于任何成员函数\***

**3.1 (= default)类外使用**

**(= default)**避免编译器做一些不必要的隐式数据转换，具体如下：

```text
class Example
{
public:
    Example(int i) {}
    Example(char c) = delete;
};


int main()
{
    Example ex(1);
    Example ex1('a');  // 无法通过编译
}
```

这个方法也能用于普通函数：

```text
void func(int i) {}
void func(char c) = delete;

int main()
{
    func(1);
    func('a');   // 编译失败
}
```



## GCC返回值优化

C++11以后，g++ 编译器默认开启复制省略（copy elision）选项，可以在以值语义传递对象时避免触发复制、移动构造函数。copy elision 主要发生在两个场景：

- 函数返回的是值语义时
- 函数参数是值语义时

### 返回值优化

返回值优化RVO（Return Value Optimization，RVO），即避免返回过程触发复制 / 移动构造函数。根据返回的值是否是匿名对象，可以分为两类：

- 具名返回值优化 `NRVO` （Named Return Value Optimization，NRVO）
- 匿名返回值优化 `URVO`（Unknown  Return Value Optimization，URVO ）

二者的区别在于返回值是具名的局部变量（NRVO）还是无名的临时对象（URVO）。

假定现在有类`Foo`，实现了复制构造函数（`ctor`）、 移动构造函数（`mtor`）。



```cpp
    class Foo { 
    public:
        Foo() { std::cout<<"default"<<std::endl; }

        Foo(const Foo& rhs) { std::cout<<"ctor"<<std::endl; }
        Foo(Foo&& rhs) { std::cout<<"mtor"<<std::endl; }
    };
```

现在，有返回类型是`Foo`的 两个函数：`return_urvo_value` 和 `return_nrvo_value` ，实现如下：



```cpp
    Foo return_urvo_value() { 
      return Foo{}; 
    }

    Foo return_nrvo_value() { 
      Foo local_obj;
      return local_obj; 
    }
```

按照常规，`return_urvo_value`函数返回`Foo{}`应该触发`mtor`， `return_nrvo_value`函数返回`local_obj`应该触发`ctor`。真的如此吗？



```cpp
    int main(int argc, char const *argv[]) {
        
      auto x = return_urvo_value();
      auto y = return_nrvo_value();  
      return 0;
    }
```

输出如下：



```cpp
    g++ rvo.cc  -o rvo && ./rvo
    default
    default
```

输出结果，令人惊讶！竟然都只调用了一次默认构造函数。这是因为编译器默认开启了RVO，为了禁止这个优化策略，需要为编译加上  *`-fno-elide-constructors`*  选项，此时输出如下：



```cpp
    $ g++ -fno-elide-constructors rvo.cc  -o rvo && ./rvo
    default
    mtor
    mtor
    default
    mtor
    mtor
```

下面对输出结果，逐个分析。

#### URVO

首先，`return_urvo_value`函数，触发两次移动构造函数，这很好理解：

1. 基于return的`Foo{}`构造`return_urvo_value`函数的返回值，触发一次；
2. 基于`return_urvo_value`函数返回的右值构造`x`，触发一次。

`return_urvo_value`函数return的`Foo{}`，中间经过两次`mtor`，才将`Foo{}`的内部数据转移到了`x`。但是，这中间的两次`mtor`是可以避免的：由于return之后`Foo{}`就结束生命周期，那为什么不直接将`Foo{}`用于`x`呢？

因此，编译器默认开启RVO，省略中间两次调用`mtor`的过程，直接基于`return_urvo_value`函数中return的`Foo{}`构造`x`。此时，整个过程简化如下：



```cpp
Foo x{}; 
```

#### NRVO

但是!!!，`return_nrvo_value`函数，怎么也触发了两次`mtor`，而不是`ctor`+ `mtor`？

1. 这是因为 `local_obj` 是局部变量，`return_nrvo_value`函数执行return语句的同时，`local_obj`的生命周期也即将结束。既然如此，与其返回`local_obj`的副本，不如直接将`local_obj`返回回去，既避免了析构`local_obj`，也避免了重新分配`Foo`对象。
2. 编译器默认开启RVO时，则可以完成上述优化。当编译加上 *`-fno-elide-constructors`*  标志禁止RVO优化时，那么编译器也会优先选择`mtor`，将`local_obj`的内部数据转移到`return_nrvo_value`的返回值中，最后用于构造`y`，避免重新为`local_obj`中的数据分配内存。

因此，`return_nrvo_value`函数，即使禁止了RVO优化，也是触发两次移动构造函数，而不是一次复制构造、一次移动构造。为了验证确实是将`local_obj`的内部数据转移到了`y`，对`return_nrvo_value`函数修改如下：



```cpp
    std::vector<int> return_nrvo_value() {

      std::vector<int> local_vec{1,2,3,4};
      std::cout<<"object address: "<< std::addressof(local_vec)
               <<" |data address:" << std::addressof(local_vec[0])<<std::endl;
      return local_vec;
    }

    int main(int argc, char const *argv[]) {

      auto y = return_nrvo_value(); 
      std::cout<<"object address: "<< std::addressof(y)
               <<" |data address:" << std::addressof(y[0])<<std::endl;
      return 0; 
    }
```

分别开启`rvo`优化、禁止`rvo`优化，输出如下：



```kotlin
    $ g++  rvo.cc  -o rvo && ./rvo
    object address: 0x7ffffc262da0 |data address:0x7ffff55e9eb0
    object address: 0x7ffffc262da0 |data address:0x7ffff55e9eb0

    $ g++ -fno-elide-constructors rvo.cc  -o rvo && ./rvo
    object address: 0x7fffc9b6ee80 |data address:0x7fffc2969eb0
    object address: 0x7fffc9b6ef00 |data address:0x7fffc2969eb0
```

从输出，可以看出：

- 当开启RVO时，不仅`y`和`local_vec`指向的数据内存一致，`y`和`local_vec`对象本身地址都是一致，即`y`就是`local_vec`；
- 当使用 *`-fno-elide-constructors`* 禁止RVO时，`y`和 `local_vec` 仍指向同一片内存区，但是此时`y`的地址不是`local_vec`的地址，说明`local_vec`将数据转移到了`y`后，`local_Vec`本身还是析构了，而`y`是基于移动构造函数重新创建的对象。

#### C++17强制编译器实现 URVO

在上面的demo中，`Foo`的`mtor`必须是可访问的，即移动构造函数没有加上`=delete`标志，也没有设置为`private`属性。到了C++17，时代变了，强制编译器实现RVO，就是即便你禁止了移动构造函数，对象也能具有URVO能力。比如，将上面的类`Foo`修改如下：



```cpp
    class Foo { 
    public:
        Foo() { std::cout<<"default"<<std::endl; }
        // 禁止复制、移动构造函数
        Foo(const Foo& rhs) = delete;
        Foo(Foo&& rhs) =delete;
    };

    int main(int argc, char const *argv[]) {
        
        auto x = return_urvo_value();
        auto y = return_nrvo_value(); 
        return 0;
    }
```

下面分别在C++14、17的编译输出：

C++14编译输出如下：



```tsx
    $ g++ -std=c++14  rvo.cc  -o rvo && ./rvo
    rvo.cc: In function ‘Foo return_urvo_value()’:
    rvo.cc:15:14: error: use of deleted function ‘Foo::Foo(Foo&&)’
       15 |   return Foo{};
          |              ^
    rvo.cc:10:3: note: declared here
       10 |   Foo(Foo&& rhs) =delete;
          |   ^~~
    rvo.cc: In function ‘Foo return_nrvo_value()’:
    rvo.cc:21:10: error: use of deleted function ‘Foo::Foo(const Foo&)’
       21 |   return local_obj;
          |          ^~~~~~~~~
    rvo.cc:9:3: note: declared here
        9 |   Foo(const Foo& rhs) = delete;
          |   ^~~
```

C++17编译输出如下：



```tsx
        $ g++ -std=c++17  rvo.cc  -o rvo && ./rvo
        rvo.cc: In function ‘Foo return_nrvo_value()’:
        rvo.cc:21:10: error: use of deleted function ‘Foo::Foo(const Foo&)’
           21 |   return local_obj;
              |          ^~~~~~~~~
        rvo.cc:9:3: note: declared here
            9 |   Foo(const Foo& rhs) = delete;
              |   ^~~
```

从两编译输出可以看出，即使在`Foo`同时禁止复制、移动构造函数时，C++17编译器仍然能强实现NRVO，但是都不支持NRVO。但是如果仅禁止`Foo`的复制构造函数呢？注意，在禁止复制构造函数时，要主动实现移动构函数，否则效果和同时禁止`ctor`和`mtor`一样。



```cpp
    class Foo { 
    public:
        Foo() { std::cout<<"default"<<std::endl; }
        // 禁止复制、移动构造函数
        Foo(const Foo& rhs) = delete;
        Foo(Foo&& rhs) { std::cout<<"mtor"<<std::endl;}
    };
```

此时输出如下：



```cpp
        $ g++ -std=c++17  rvo.cc  -o rvo && ./rvo
        default
        default
        $ g++ -std=c++14  rvo.cc  -o rvo && ./rvo
        default
        default
```

因此，可总结如下：当函数的返回类型是值类型时，

1. URVO：在C++17之前，对象的`motor`必须是可访问的，才能开启URVO。

   

   ```cpp
       // return_urvo_value 导致编译失败
       class Foo { 
       public:
           Foo() =default;
           Foo(const Foo& rhs) =default;
           Foo(Foo&& rhs) =delete;      // mtor 不可访问
       };
   
       // 编译通过
       class Foo { 
       public:
           Foo() =default;
           Foo(const Foo& rhs) =default;
       };
   ```

   C++17开始，即使完全禁止了对象的`ctor`、`motr`，编译器一样可以实现URVO。

2. NRVO：对象的`mtor`必须可访问的，才能开启。

#### URVO 应用

根据URVO特性，我么可以为 `std::unique_ptr`、 `std::atomic`等提供一个工厂函数 `make_instance`。



```cpp
    template <typename T, typename... Args>
    T make_instance(Args&& ... args) {
        return T {std::forward<Args>(args)...};
    }

    int main(int argc, const char* argv[]) {
        // 普通类型
        int i   = make_instance<int>(42);
        // std::unique_ptr 实现了 移动构造函数，因此可以编译成功 
        auto up = make_instance<std::unique_ptr<int>>(new int{ 42 }); 
        // 禁止了复制构造函数，但是也没有实现移动构造函数，因此要到 C++17 才能编译过
        auto ai = make_instance<std::atomic<int>>(42);                  
        return 0;
    }
```

在上面的`make_instance`对于`std::unique_ptr`、`std::atomic`要求不同：

- `std::unique_ptr`：虽然禁止了`ctor`，但实现`mtor`，因此它在C++11中可以开启NRVO。注意，在C++14中已经为`std::unique_ptr`提供了工厂函数`std::make_unique`，实现如下：

  

  ```cpp
        // 和 make_instance 如出一辙
        template <typename _Tp, typename... _Args>
        unique_ptr<_Tp> make_unique(_Args && ...__args)
        {
          return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...));
        }
  ```

- `std::atomic`：同时禁止了`ctor`、`mtor`，因此必须等到 C++17，`make_instance`函数才能为`std::atmoic`创建对象。

### 函数值传递

在 [函数模板之值传递与引用传递的不同类型推导规则辨析](https://links.jianshu.com/go?to=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkyMjIxMzIxNA%3D%3D%26mid%3D2247483974%26idx%3D1%26sn%3D2be406fac97ff57e7a864bf8a509b1f1%26chksm%3Dc1f68c77f6810561412366b292a567882b4dcfc178fe9d7fc206a88f9f22c2e05d498cce5d5b%26token%3D421354495%26lang%3Dzh_CN%23rd) 一文中，深度讲解了函数模板基于值传递和引用传递的优劣。在讲值传递时，未必总是发生复制行为：`pass_by_value`函数传入右值时，也会发生copy elision 行为，即使禁止编译器的copy elision 行为，也是优先调用对象的`mtor`。



```cpp
    void pass_by_value(Foo foo) { 
      // ...
    }

    int main(int argc, char const *argv[]) {
      auto x = return_urvo_value();
      auto y = return_nrvo_value(); 

      pass_by_value(Foo{});
      pass_by_value(std::move(x));

      return 0;
    }
```

最终的输出也是调用默认三次构造函数：



```cpp
    $ g++ -std=c++11  rvo.cc  -o rvo && ./rvo
    default
    default
    default
```

到此，copy elision 的两个主要应用场景基本分析结束。



作者：fibonaccii
链接：https://www.jianshu.com/p/d4ec1b7334fd
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 构建与工具

## CMAKE

https://www.bilibili.com/video/BV1vR4y1u77h/?spm_id_from=333.337.search-card.all.click 从零开始详细介绍CMake

## 工具方法

### typora设置自动上传图片和拷贝图片到指定文件夹

![image](https://github.com/00lab/osPrj/assets/9030950/4a1ed736-d39c-4bf9-8af5-24ee871c88b7)

每次上传图片会自动执行 typora-upload-helper.py：

```python
import os
import sys
import requests
import time
import hashlib
import struct

def upload(imagePath):
    if len(imagePath) == 0 or imagePath.startswith("http"):
        print(imagePath)
        return

    timestamp = int(time.time())
    publicKey = "10067"
    privateKey = "bIbT0orLEO5FDGyciQKL0ounccep04qk"
    text = privateKey + str(timestamp)
    hl = hashlib.md5()
    hl.update(text.encode())
    verifyCode = hl.hexdigest()
    url = str.format(
        "http://3ms.huawei.com/hi/restnew/editor/attach/upload?app_id=67&public_key={}&current_timestamp={}"
        "&verify_code={}",
        publicKey, timestamp, verifyCode)
    (path, filename) = os.path.split(imagePath)
    files = {"attach_binary": open(imagePath, 'rb')}
    data = {"action": "upload_image", "originalfile": filename}
    headers = {
        "Accept": "*/*",
        "Accept-Encoding": "gzip, deflate",
        "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6",
        "x-requested-with": "XMLHttpRequest",
        "User-Agent":
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) "
            "Chrome/88.0.4324.104 Safari/537.36",
        "Host": "3ms.huawei.com",
        "Origin": "http://3ms.huawei.com",
        "Referer": "http://3ms.huawei.com/km/static/md/",
        "Pragma": "no-cache",
    }
    # 
    response = requests.post(url, data=data, headers=headers, files=files)
    imgUrl = response.json()["imgUrl"]
    index = imgUrl.rfind('@')
    if index > 0 :
        imgUrl = imgUrl[0:index]
    dst_path = 'D:/courses/typora_img/' + filename
    src_file = open(imagePath, 'rb')                                                                                                                                                                                                                                                                                                                            
    img_bytes = src_file.read()
    src_file.close()
    write_byte_to_file(dst_path, img_bytes)
    imgUrl += ')[local](' + dst_path
    print(imgUrl)
    #print(imagePath)


def write_byte_to_file(file_name, write_byte):
    file_dir = os.path.dirname(file_name)
    if not os.path.exists(file_dir):
        os.makedirs(file_dir)
    op_file = open(file_name, 'wb')
    op_file.write(write_byte)
    op_file.close()


# def write_str_to_file(file_name, write_text_str):
#     file_dir = os.path.dirname(file_name)
#     if not os.path.exists(file_dir):
#         os.makedirs(file_dir)
#     op_file = open(file_name, 'a')
#     op_file.writelines(write_text_str)
#     op_file.close()

if __name__ == '__main__':
    for i in range(1, len(sys.argv)):
        upload(sys.argv[i])
        #write_str_to_file('D:/courses/typera_log_test.txt', sys.argv[i])

```

[使用Python脚本通过typora上传图片到github打造免费私人图床 - 义美-小义 - 博客园 (cnblogs.com)](https://www.cnblogs.com/shaozhu520/p/16248267.html)

### typora+gitee配置方法

记录于2023-07-01

配置参考：

[gitee搭配图床picgo教程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/459743173)

[(105条消息) Markdown书写软件Typora的使用--图片上传（PicGo与Github/Gitee）及排版_typora上传图片_雨翼轻尘的博客-CSDN博客](https://blog.csdn.net/m0_55746113/article/details/122681678)

报错

Failed to fetch

（原来是版本太低了，参考 https://blog.csdn.net/WEDUEST/article/details/112341966 ，博客里的server设置2.3才有，升级后也不用设置了）

Request failed with status code 403 （参考https://www.cnblogs.com/verg/p/16714826.html) 估计是因为gitee插件太老了，用博客所说的 githubPlus。

